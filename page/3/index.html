<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>逝去的美好</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="逝去的美好">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="逝去的美好">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="逝去的美好">
  
    <link rel="alternate" href="/atom.xml" title="逝去的美好" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/plugin/bganimation/bg.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <div class="widget-wrap mobile-header">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://avatars0.githubusercontent.com/u/20333903?v=3&amp;s=460">
    <h2 class="author">geekzw</h2>
    <h3 class="description">null</h3>
    <div class="count-box">
      <a href="/archives"><div><strong>30</strong><br>文章</div></a>
      <a href="/categories"><div><strong>7</strong><br>分类</div></a>
      <a href="/tags"><div><strong>6</strong><br>标签</div></a>
    </div>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

        <section id="main">
  
    <article id="post-类加载" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/10/类加载/" class="article-date">
  <time class="post-time" datetime="2016-11-10T03:20:30.000Z" itemprop="datePublished">
    <span class="post-month">11月</span><br/>
    <span class="post-day">10</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/10/类加载/">类加载</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用、卸载7个阶段。其中验证、准备、解析3个部分统称为链接。加载、验证、准备、初始化和卸载这5个阶段顺序是确定的，类的加载过程必须按照这种顺序按部就班的开始，而解析阶段不一定，它可能在初始化后面（运行时绑定）。</p>
<h2 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h2><h3 id="一、-加载，验证，准备"><a href="#一、-加载，验证，准备" class="headerlink" title="一、 加载，验证，准备"></a>一、 加载，验证，准备</h3><p>这几个过程，在虚拟机规范中并没有明确规定开始时间和条件，要根据虚拟机具体实现确定。</p>
<h3 id="二、-初始化"><a href="#二、-初始化" class="headerlink" title="二、 初始化"></a>二、 初始化</h3><h4 id="主动初始化"><a href="#主动初始化" class="headerlink" title="主动初始化"></a>主动初始化</h4><ol>
<li>当使用new关键字实例化对象、读取或设置静态字段、调用静态方法的时候，如果类没有被初始化，那么要执行初始化操作</li>
<li>反射调用时，如果类没有被初始化，那么要执行初始化操作</li>
<li>初始化一个类时，如果父类没有被初始化，那么需要先触发父类的初始化</li>
<li>虚拟机启动时，需要先初始化包含main()的主类</li>
<li><p>当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个句柄锁对应的类没有进行过初始化，则需要先触发其初始化</p>
<h4 id="被动初始化"><a href="#被动初始化" class="headerlink" title="被动初始化"></a>被动初始化</h4><p><strong>除了上面5种触发初始化的场景，其他的引用类的方式都不会触发初始化，称为被动初始化</strong></p>
</li>
<li><p>通过子类引用父类的静态字段，不会导致子类初始化，对于静态字段，只有直接定义这个字段的类才会被初始化</p>
</li>
<li>通过数组定义来引用类，不会触发此类的初始化。（个人理解：当定义一个类型的数组时，这个变量代表的是数组本身，无论是我们所能调用的方法或属性，都与具体的类无关，如果说初始化，也是对数组本身这个类初始化，不会初始化所能存放的类型的类）</li>
<li>常量在比哪一阶段会存入调用类的常量池中，因此调用常量，不会触发定义常量的类的初始化<br>接口与类的最大不同点在于，当一个类初始化时，要求它的父类全部初始化成功，但接口没有此要求，只有在真正用到父类的时候，才会要求初始化</li>
</ol>
<h2 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>加载需要完成3件事</p>
<ol>
<li>通过一个类的全限定名来获取此类的二进制字节流</li>
<li>将字节流代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存（HotSpot虚拟机是放在方法区）中生成一个代表这个类的Class对象，作为方法区这个类的各种数据的访问入口</li>
</ol>
<p><strong>上述3点中，第一点具有极大的灵活性，因为虚拟机只规定获取二进制字节流，并没有规定获取的方式，所以才有了现在的从ZIP,WAR,JAR,网络等各个渠道。类加载阶段（非数组类）是可控性最强的地方，我们可以选择用系统提供的引导类加载器，也可以自定义类加载器。类加载完成之后，产生的结果就是把二进制流按照虚拟机所需格式存储在方法区。然后内存中生成一个Class对象作为程序方位的外部接口。</strong><br>连接和连接阶段的部分内容是交叉进行的，只是开始动作按先后顺序</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p><strong>验证的主要作用是确保Class文件的字节流中包含的信息符合当前虚拟机的要求，防止危害虚拟机自身安全严恒主要分为4个阶段</strong></p>
<ol>
<li>文件格式验证<br>改阶段的验证主要目的是保证输入的字节流能正确地解析并存储于方法区之内<br>主要验证点有：是否以魔数0xCAFEBABE开头，常量池的常量是否有不被支持的常量类型等</li>
<li>元数据验证<br>对字节码描述的信息进行语义分析，保证其描述的信息符合java语言规范<br>主要验证点：这个类是否有父类，是否继承自不允许继承的类类中字段、方法是否与父类矛盾等</li>
<li>字节码验证<br>对类的方法体进行效验分析，保证被效验类的方法在运行时不会做出危害虚拟机的事件<br>主要验证点：保证跳转指令不会跳转到方法体以外的字节码指令上，保证方法体中的类型转换的有效性等</li>
<li>符号引用验证<br>可以看做是对类自身以外的信息进行匹配性效验<br>主要验证点：符号引用中通过字符串面熟的全限定名是否能找到对应的类等</li>
</ol>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段的主要工作是在方法区中给变量分配内存，并设置类变量初始值。这里强调的是类变量，和初始值。实例变量则在初始化阶段进行。初始值表示的是零值，例如public static int value = 123；在准备阶段只会赋值为0，初始化阶段才会赋值为123</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><h4 id="符号引用"><a href="#符号引用" class="headerlink" title="符号引用"></a>符号引用</h4><p>符号引用以一组符号来描述所引用的目标，可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。符号引用与虚拟机内存布局无关，引用的目标不一定已经加载到内存中</p>
<h4 id="直接引用"><a href="#直接引用" class="headerlink" title="直接引用"></a>直接引用</h4><p>直接引用可以使直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄，直接引用是和虚拟机实现的内存布局相关的，有了直接引用，目标必定已经在内存中。<br><strong>解析阶段是虚拟机讲常量池内的符号引用替换为直接引用的过程</strong></p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化是类加载的最后一个阶段了。简单来说，初始化阶段就是执行init()方法的阶段，init方法的生成是由编译器自动收集勒种的所有类变量的赋值动作和静态语句块中的语句合并产生的。收集顺序是按语句在源文件中出现的顺序决定的。init方法不一定会有，如果类中没有静态变量和静态语句块，则不会生成init方法</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/10/类加载/" data-id="cj597eiz6002m9ux335pvu26t" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-JVM垃圾收集算法" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/09/JVM垃圾收集算法/" class="article-date">
  <time class="post-time" datetime="2016-11-09T03:08:30.000Z" itemprop="datePublished">
    <span class="post-month">11月</span><br/>
    <span class="post-day">09</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/09/JVM垃圾收集算法/">JVM垃圾收集算法</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h2><p>标记清除算法是最基础的算法，算法分为标记和清除两个阶段：首先是标记出所有需要回收的对象，在标记完成后统一回收。<br>标记过程：从GC Roots（虚拟机栈中引用的对象，方法区中类的静态属性引用的对象，方法区中常量引用的对象，本地方法栈中JNI引用的对象）开始进行可达性分析，从这些节点开始向下搜索，搜索走过的路径成为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明对象不可用，需要被回收<br>清除过程：在标记过程后，所有需要回收的对象都已经被标记，此时就找到标记的对象进行垃圾回收<br>缺点：效率问题，标记和清除过程效率都不高；空间问题，标记清除后会产生大量的内存碎片，空间碎片化，导致后来的大对象无法找到足够大的连续内存而不得不触发另一次垃圾回收。</p>
<h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>复制算法是在标记清除的基础上，试图解决空间碎片化的问题，它把内存空间分成大小相等的两块，每次只使用其中的一块，当一块用完的时候，对这块进行标记，活的对象转移到另一块内存，然后把当前的内存直接清理掉<br>优点：解决了内存碎片化，分配内存只需要移动堆顶指针，顺序分配，效率高<br>缺点：显而易见，空间利用率低，每次只能使用一般内存，当对象存活率高时，每次要复制大量的对象，效率低</p>
<h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p>针对复制算法空间利用率低的缺点。标记整理的做法是：标记过程还是标记清除算法的逻辑，标记过后，不是直接回收对象，而是让对象向内存一端移动，然后再清理掉边界以外的内存</p>
<p>当前商业虚拟机的垃圾收集都采用分代收集算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块，一般是把ava堆分为新生代和老年代，这样就可以根据各个年代的特点采用最合适的收集算法。在新生代中每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法回收。<br>在新生代中，因为98%的对象都是“朝生夕死”，所以把新生代堆分为一个较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor空间。当回收时，讲Eden和Survivor中还存活着的对象一次性复制到另一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor。HotSpot虚拟机默认Eden和Survivor大小比例8：1.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/09/JVM垃圾收集算法/" data-id="cj597eix400089ux3pew8bhk8" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-二叉搜索树" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/08/二叉搜索树/" class="article-date">
  <time class="post-time" datetime="2016-11-08T11:26:39.000Z" itemprop="datePublished">
    <span class="post-month">11月</span><br/>
    <span class="post-day">08</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/08/二叉搜索树/">二叉搜索树</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/algorithm/">algorithm</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><img src="http://ofy9dm2ii.bkt.clouddn.com/image/article/binaryTree.png" alt="此处输入图片的描述"><br>上图就是一个二叉查找树的结构。从图中可以看出，每个父节点均大于他的左孩子，小于它的右孩子。</p>
<h2 id="节点类"><a href="#节点类" class="headerlink" title="节点类"></a>节点类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        <span class="keyword">int</span> count;</div><div class="line">        TreeNode left;</div><div class="line">        TreeNode right;</div><div class="line">        TreeNode parent;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.val = val;</div><div class="line">            left = <span class="keyword">null</span>;</div><div class="line">            right = <span class="keyword">null</span>;</div><div class="line">            parent = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="构建树"><a href="#构建树" class="headerlink" title="构建树"></a>构建树</h2><p>构建树比较简单，按照二叉查找树的规则，递归创建就行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">addBinaryTree</span><span class="params">(<span class="keyword">int</span> a,TreeNode root)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</div><div class="line">            root = <span class="keyword">new</span> TreeNode(a);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(a&lt;root.val) root.left = addBinaryTree(a,root.left);</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a&gt;root.val)root.right = addBinaryTree(a,root.right);</div><div class="line">        <span class="keyword">else</span> root.count++;</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">find</span><span class="params">(<span class="keyword">int</span> a,TreeNode root)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(root.val == a)<span class="keyword">return</span> root;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; a)&#123;</div><div class="line">                <span class="keyword">return</span> find(a,root.left);</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; a)&#123;</div><div class="line">                <span class="keyword">return</span> find(a,root.right);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>根据二叉查找树的规则，递归遍历树，直到找到与目标相同的节点</p>
<h2 id="最大最小节点"><a href="#最大最小节点" class="headerlink" title="最大最小节点"></a>最大最小节点</h2><p>也是非常简单的递归，不再给出代码</p>
<h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><p>删除节点是最复杂的。对照上图分析，如果删除的是叶子节点，那么直接删除，父节点的对应儿子至空。如果删除的不是叶子节点，但是该节点只有一个孩子，那么就删除该节点，把孩子节点放到父节点的位子。如果删除的不是叶子几点，并且该节点有两个孩子。此时的做法是找到该节点的右子树中的最小值，跟该节点对换，然后递归删除该节点。因为该节点的右子树中的最小值肯定是叶子节点或者只有一个孩子，所以删除比较容易。之所以选择右子树的最小值交换，对照图分析一下就知道。按照二叉查找树的规则，一个节点大于该左孩子，小于右孩子。那么该节点的右子树中的最小值一定是大于左孩子，而且小于等于右孩子，这样就能保证删除而且不破坏树的结构。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**删除元素*/</span>  </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(T t)</span>  </span></div><div class="line">   &#123;  </div><div class="line">       rootTree = remove(t,rootTree);  </div><div class="line">   &#125; <span class="comment">/**在某个位置开始判断删除某个结点*/</span>  </div><div class="line">   <span class="function"><span class="keyword">public</span> BinaryNode&lt;T&gt; <span class="title">remove</span><span class="params">(T t,BinaryNode&lt;T&gt; node)</span>  </span></div><div class="line">   &#123;  </div><div class="line">       <span class="keyword">if</span>(node == <span class="keyword">null</span>)  </div><div class="line">           <span class="keyword">return</span> node;<span class="comment">//没有找到,doNothing  </span></div><div class="line">       <span class="keyword">int</span> result = t.compareTo(node.data);  </div><div class="line">       <span class="keyword">if</span>(result&gt;<span class="number">0</span>)  </div><div class="line">           node.right = remove(t,node.right);  </div><div class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(result&lt;<span class="number">0</span>)  </div><div class="line">           node.left = remove(t,node.left);  </div><div class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>&amp;&amp;node.right!=<span class="keyword">null</span>)  </div><div class="line">       &#123;  </div><div class="line">           node.data = findMin(node.right).data;  </div><div class="line">           node.right = remove(node.data,node.right);  </div><div class="line">       &#125;  </div><div class="line">       <span class="keyword">else</span>  </div><div class="line">           node = (node.left!=<span class="keyword">null</span>)?node.left:node.right;  </div><div class="line">       <span class="keyword">return</span> node;  </div><div class="line">             </div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>代码中查找最大最小节点没有给出，实现比较简单</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/08/二叉搜索树/" data-id="cj597eiye001c9ux3mjusv0re" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/">algorithm</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-android-source" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/03/android-source/" class="article-date">
  <time class="post-time" datetime="2016-11-03T11:05:33.000Z" itemprop="datePublished">
    <span class="post-month">11月</span><br/>
    <span class="post-day">03</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/03/android-source/">android source</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/source/">source</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://androidblog.cn/index.php/Source/newSourceList/p/1" target="_blank" rel="external">android最新源码汇总</a><br>转载自：<a href="http://androidblog.cn/index.php/Source/newSourceList/p/1" target="_blank" rel="external">http://androidblog.cn/index.php/Source/newSourceList/p/1</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/03/android-source/" data-id="cj597eixx000v9ux303w274im" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-剑指offer-重建二叉树" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/02/剑指offer-重建二叉树/" class="article-date">
  <time class="post-time" datetime="2016-11-02T05:53:50.000Z" itemprop="datePublished">
    <span class="post-month">11月</span><br/>
    <span class="post-day">02</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/02/剑指offer-重建二叉树/">剑指offer_重建二叉树</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/algorithm/">algorithm</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本体有两个知识点，一个是二叉树的遍历，另一个就是递归。下面就分别从这两个知识点分析这题解法。</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归应该是大家都熟悉的东西。今天打算从java虚拟机的层面说一说递归。为了表达清楚，先上一张盗来的图<br>  <img src="http://ofy9dm2ii.bkt.clouddn.com/image/article/java_stack.jpg" alt="java虚拟机栈"></p>
<p>java虚拟机有一个区叫做虚拟机栈区。虚拟机栈描述的是java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。从上图中可以看出，每当有个方法调用的时候，就会有一个栈帧被压入栈中。我们平时使用递归的时候，最需要注意的一点就是要有结束条件，否则就会报栈溢出的错误。站在虚拟机栈的角度就很好理解了，如果你只入栈，不出栈，那么栈的空间势必被消耗殆尽。递归还有个特点，能保持当前状态。从图中可以看出，每个栈帧就是一块区域，这个区域的状态在某个时间点是固定的，不会随其他的栈帧的改变而改变。代码角度说就是，当在方法中进入下次递归后，本次的变量都会保持现状，当递归退回到当前时，继续按原来的状态执行。</p>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>二叉树的遍历分为前序遍历，中序遍历，后序遍历。通俗易懂的再说一遍，根左右，左根右，左右根。知道规则后我们会发现，如果知道其中的两个遍历结果，那么我们都能恢复整棵二叉树。此题就用到这个知识点。</p>
<h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><p>题目中给了前序遍历结果和中序遍历结果，分别是{1,2,4,7,3,5,6,8}和{4,7,2,1,5,3,8,6}。利用这两个结果，我们可以恢复整个二叉树如下图<br>  <img src="http://ofy9dm2ii.bkt.clouddn.com/image/articlebinaryTree.png" alt="二叉树"></p>
<p>恢复后树就长这样。结合图和二叉树的遍历规则，很容易发现，前序遍历的首位，就是树的根节点。因为前序遍历是按根左右的顺序遍历二叉树，也就是先取根，再取左子树，最后取右子树。那么此时再想一下中序遍历规则，先取左子树，再取根，最后取右子树。那么也就是说，如果我们在中序遍历中找到了根节点，根节点前面的就是左子树，根节点右边的就是右子树。至此，我们已经找到了根节点，和根节点的左子树和右子树，root:1，leftChild:{2,4,7},rightChild:{3,5,6,8}。这个时候如果我们队递归敏感一点，问题已经快解决了。因为leftChild本身又是一棵树，我们可以按照前面的思想分析它，又可以找到它的根节点和左右子树。对于递归，我的理解是把过程当做一个黑盒，我只关注我的输入和输出，不过分关心具体流程，因为既然是递归，那么每次执行的逻辑多事类似的，没必要一步一步的纠结。比如我们这题，分析到现在，第一个流程已经分析完成，我们发现，我关心的是哪个位置是根节点，哪个区域是左子树，哪个区域是右子树。我只需要找出这些入参就行了。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>本不想贴代码，因为自己写的很原始，跟那些大牛的代码比起来，有点复杂，不过，用作自己以后回头看吧，大牛反正不会关心的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">getTree</span><span class="params">(<span class="keyword">int</span>[] pre,<span class="keyword">int</span> ps,<span class="keyword">int</span> pe,<span class="keyword">int</span>[] fol,<span class="keyword">int</span> fs,<span class="keyword">int</span> fe )</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(ps&gt;pe||fs&gt;fe)<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(pre[ps]);</div><div class="line">        <span class="keyword">int</span> follow_root = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(follow_root&lt;fe&amp;&amp;(fol[follow_root]!=pre[ps]))&#123;</div><div class="line">            follow_root++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(follow_root&gt;fe)<span class="keyword">throw</span> <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        </div><div class="line">        node.left = getTree(pre,ps+<span class="number">1</span>,ps+(follow_root-fs),fol,fs,follow_root);</div><div class="line">        </div><div class="line">        node.right = getTree(pre,ps+(follow_root-fs)+<span class="number">1</span>,pe,fol,follow_root+<span class="number">1</span>,fe);</div><div class="line">        <span class="keyword">return</span> node;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/02/剑指offer-重建二叉树/" data-id="cj597eiyh001j9ux3aoorkbry" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/">algorithm</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-剑指offer-从尾到头打印链表" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/01/剑指offer-从尾到头打印链表/" class="article-date">
  <time class="post-time" datetime="2016-11-01T12:37:41.000Z" itemprop="datePublished">
    <span class="post-month">11月</span><br/>
    <span class="post-day">01</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/01/剑指offer-从尾到头打印链表/">剑指offer_从尾到头打印链表</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/algorithm/">algorithm</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这道题非常简单，称不上是算法，本不想说。但是我这个人，已经粗心到一定程度了，错了2次才过，并且感觉以后碰到细节的地方还是得错。首先就是要判空，链表为空直接返回个空数组就行了。第二就是遍历链表结束的时候，我是用的正常while循环，没有用do…while;所以循环跳出后还会有一个数字需要打印，切记。题目链接<a href="http://www.nowcoder.com/ta/coding-interviews?page=1" target="_blank" rel="external">点这里</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/01/剑指offer-从尾到头打印链表/" data-id="cj597eiyg001f9ux3q0kf68qk" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/">algorithm</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-深入理解Handler" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/01/深入理解Handler/" class="article-date">
  <time class="post-time" datetime="2016-11-01T08:43:27.000Z" itemprop="datePublished">
    <span class="post-month">11月</span><br/>
    <span class="post-day">01</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/01/深入理解Handler/">深入理解Handler</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/android/">android</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="关联类"><a href="#关联类" class="headerlink" title="关联类"></a>关联类</h2><h3 id="Message"><a href="#Message" class="headerlink" title="Message"></a><font color="#47C4EA"><a href="https://geekzw.github.io/2016/11/01/Message/index.html" target="_blank" rel="external">Message</a></font></h3><h3 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a><font color="#47C4EA"><a href="https://geekzw.github.io/2016/11/01/MessageQueue/index.html" target="_blank" rel="external">MessageQueue</a></font></h3><h3 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a><font color="#47C4EA"><a href="https://geekzw.github.io/2016/11/01/Looper/index.html" target="_blank" rel="external">Looper</a></font></h3><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>handler是发送消息和最终处理消息的类。从发送消息的方式看，有两种，一种是handler.post(Runnable)，另一种是handler.sendMessage()。</p>
<h2 id="handler流程解析"><a href="#handler流程解析" class="headerlink" title="handler流程解析"></a>handler流程解析</h2><h3 id="handler-post-方式"><a href="#handler-post-方式" class="headerlink" title="handler.post()方式"></a>handler.post()方式</h3><p>handler.post()接受一个Runnable对象，run方法中的代码执行在UI线程也就是主线程。跟进post方法可以发现，其实还是把Runnable通过getPostMessage方法包装成一个Message对象，其中Runnable实例赋值给Message对象的callback成员变量。最后调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">        MessageQueue queue = mQueue;</div><div class="line">        <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</div><div class="line">            RuntimeException e = <span class="keyword">new</span> RuntimeException(</div><div class="line">                    <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</div><div class="line">            Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这个方法很简单，就是对与handler绑定的msgqueue判空，不为空则把当前包装了Runnable的msg放入messageQueue。此处调用的enqueueMessage(queue, msg, uptimeMillis);在<font color="#47C4EA"><a href="https://geekzw.github.io/2016/11/01/MessageQueue/index.html" target="_blank" rel="external">MessageQueue</a></font>类中有详细解释至此，算是把一个Runnable对象放入了消息队列中，那么什么时候会执行这个Runnable呢？那就要看<font color="#47C4EA"><a href="https://geekzw.github.io/2016/11/01/Looper/index.html" target="_blank" rel="external">Looper</a></font>类了，我们知道，Looper类的主要作用就是从消息队列中取出消息，最后发送给目标handler。我们在分析Looper类的时候，分析过一个loop（）方法，它就是用来循环取出消息队列中的消息的方法，其中当取出一个有效的消息后，会执行msg.target.dispatchMessage(msg);这行代码。msg当然就是Message的一个实例，在<font color="#47C4EA"><a href="https://geekzw.github.io/2016/11/01/Message/index.html" target="_blank" rel="external">Message</a></font>类中，我们知道有一个target的成员变量，作用是保存这个消息最终到达的handler的实例。那么这行代码调用的就是handler.dispatchMessage()这个方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</div><div class="line">            handleCallback(msg);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            handleMessage(msg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>看到这里，终于是看到了我们最初post的那个Runnable对象了，它其实就是msg.callback。当它不位空的时候调用handleCallback(msg)这个方法更是简单，就一行代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</div><div class="line">        message.callback.run();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>看到这里就恍然大悟，为什么post的Runnable对象，run里面的代码是跑在UI线程的了。因为就是在UI线程中在一个合适的时间把run方法当做一个普通方法调用了，没有把它放入一个Thread中当做子线程处理。这里容易理解错是因为我们平时使用Runnable都是放入一个子线程中执行，不会手动调用run方法。平时开发中，使用postDelayed比较多，用于延时执行一段代码。</p>
<h3 id="handler-sendMessage-方式"><a href="#handler-sendMessage-方式" class="headerlink" title="handler.sendMessage()方式"></a>handler.sendMessage()方式</h3><p>sendMsg方法有很多重载，但是都不难理解，只是指定的参数不一样，有些参数不想系统默认。如果调用的sendMessage（）不是message实例，则系统会调用Message.obtain获取一个消息，来包装传入的参数，obtain方法在Message中有详细分析。后面流程与post方式一致，压入消息列表，loop循环取出，调用msg.target.dispatchMessage(msg);这次callback为空。则走else流程。首先判断mCallback是否为空。Callback是一个接口，里面就一个handleMessage(msg)方法，handler中的Callback是我们平时经常用的标准的回调模式。如果mCallback不为空，则回调handleMessage，否则调用handleMessage，sdk对这个方法的注释说，子类必须重写这个方法，用来处理接受到的消息。</p>
<h3 id="对handler机制的一个疑问"><a href="#对handler机制的一个疑问" class="headerlink" title="对handler机制的一个疑问"></a>对handler机制的一个疑问</h3><p>当app启动的时候，会执行ActivityThread类中的main方法。main方法代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"ActivityThreadMain"</span>);</div><div class="line">        SamplingProfilerIntegration.start();</div><div class="line"></div><div class="line">        <span class="comment">// CloseGuard defaults to true and can be quite spammy.  We</span></div><div class="line">        <span class="comment">// disable it here, but selectively enable it later (via</span></div><div class="line">        <span class="comment">// StrictMode) on debug builds, but using DropBox, not logs.</span></div><div class="line">        CloseGuard.setEnabled(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">        Environment.initForCurrentUser();</div><div class="line"></div><div class="line">        <span class="comment">// Set the reporter for event logging in libcore</span></div><div class="line">        EventLogger.setReporter(<span class="keyword">new</span> EventLoggingReporter());</div><div class="line"></div><div class="line">        <span class="comment">// Make sure TrustedCertificateStore looks in the right place for CA certificates</span></div><div class="line">        <span class="keyword">final</span> File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</div><div class="line">        TrustedCertificateStore.setDefaultUserDirectory(configDir);</div><div class="line"></div><div class="line">        Process.setArgV0(<span class="string">"&lt;pre-initialized&gt;"</span>);</div><div class="line"></div><div class="line">        Looper.prepareMainLooper();</div><div class="line"></div><div class="line">        ActivityThread thread = <span class="keyword">new</span> ActivityThread();</div><div class="line">        thread.attach(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</div><div class="line">            sMainThreadHandler = thread.getHandler();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</div><div class="line">            Looper.myLooper().setMessageLogging(<span class="keyword">new</span></div><div class="line">                    LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// End of event ActivityThreadMain.</span></div><div class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</div><div class="line">        Looper.loop();</div><div class="line"></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>我们只关心跟handler有关的代码，其实主要也就是创建looper和handler。21行可以看到调用了Looper.prepareMainLooper();这个方法在Looper类分析中有做解释。就是创建一个mainLooper。接着创建一个sMainThreadHandler，然后调用Looper.loop();这是标准的在一个线程中创建handler的方式，我们自己使用的时候，也应该这么创建。看到这里我就有疑问了。主线程中调用了loop方法，我们都知道，loop方法里面是一个无限循环，并且带阻塞的。那为什么app还能继续执行，并没有因此而阻塞在这里。后来发现，原来我对app的运行流程一直理解有误。app大部分时间确实是处于阻塞状态。现在我们来想一想，线程是什么东西。线程的作用就是执行一块代码，当代码运行完了，它也就结束了。但是想想我们的app，它可是可以长期运行，不会因为线程执行结束而死掉的。那我们平时要想让一个线程一直运行下去，做法是什么呢？就是在线程中写个死循环。这么一想，也算是大致理解了mainLooper这个东西。当创建了mainLooper之后，它就会进入死循环不断的从MessageQueue中取消息，那么在app启动过程中，系统会系统还会创建必要的服务进程，这些进程会通过binder发送给主线程事件，比如aty的create start等等。这时我们可以看一下MainThreadHandler这个东西了。MainThreadHandler类型为H，就是ActivityThread的内部类，重写handMessage方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">"&gt;&gt;&gt; handling: "</span> + codeToString(msg.what));</div><div class="line">            <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">                <span class="keyword">case</span> LAUNCH_ACTIVITY: &#123;</div><div class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"activityStart"</span>);</div><div class="line">                    <span class="keyword">final</span> ActivityClientRecord r = (ActivityClientRecord) msg.obj;</div><div class="line"></div><div class="line">                    r.packageInfo = getPackageInfoNoCheck(</div><div class="line">                            r.activityInfo.applicationInfo, r.compatInfo);</div><div class="line">                    handleLaunchActivity(r, <span class="keyword">null</span>, <span class="string">"LAUNCH_ACTIVITY"</span>);</div><div class="line">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</div><div class="line">                &#125; <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> RELAUNCH_ACTIVITY: &#123;</div><div class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"activityRestart"</span>);</div><div class="line">                    ActivityClientRecord r = (ActivityClientRecord)msg.obj;</div><div class="line">                    handleRelaunchActivity(r);</div><div class="line">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</div><div class="line">                &#125; <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> PAUSE_ACTIVITY: &#123;</div><div class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"activityPause"</span>);</div><div class="line">                    SomeArgs args = (SomeArgs) msg.obj;</div><div class="line">                    handlePauseActivity((IBinder) args.arg1, <span class="keyword">false</span>,</div><div class="line">                            (args.argi1 &amp; USER_LEAVING) != <span class="number">0</span>, args.argi2,</div><div class="line">                            (args.argi1 &amp; DONT_REPORT) != <span class="number">0</span>, args.argi3);</div><div class="line">                    maybeSnapshot();</div><div class="line">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</div><div class="line">                &#125; <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> PAUSE_ACTIVITY_FINISHING: &#123;</div><div class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"activityPause"</span>);</div><div class="line">                    SomeArgs args = (SomeArgs) msg.obj;</div><div class="line">                    handlePauseActivity((IBinder) args.arg1, <span class="keyword">true</span>, (args.argi1 &amp; USER_LEAVING) != <span class="number">0</span>,</div><div class="line">                            args.argi2, (args.argi1 &amp; DONT_REPORT) != <span class="number">0</span>, args.argi3);</div><div class="line">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</div><div class="line">                &#125; <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> STOP_ACTIVITY_SHOW: &#123;</div><div class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"activityStop"</span>);</div><div class="line">                    SomeArgs args = (SomeArgs) msg.obj;</div><div class="line">                    handleStopActivity((IBinder) args.arg1, <span class="keyword">true</span>, args.argi2, args.argi3);</div><div class="line">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</div><div class="line">                &#125; <span class="keyword">break</span>;</div></pre></td></tr></table></figure></p>
<p>代码过多，不全部贴出来了。从这个方法中可以看出来了。系统发的消息都在这里处理了，比如app启动，重启等消息。app的启动和运行就是不停的执行各种消息的过程，当暂时没有消息的时候，app就会阻塞在当前状态。这个时候还有一个疑问，一旦创建了mainLooper，调用了loop方法，主线程就处于无限循环和阻塞状态，理论上着会占用很大的cup。但是实际上，当前没有可取的消息的时候，线程将会被挂起。再有消息到来的时候再唤醒，这个流程采用的是epllo模式，这个模式在分析MessageQueue的时候有做解释。</p>
<h3 id="使用handler需要注意的地方"><a href="#使用handler需要注意的地方" class="headerlink" title="使用handler需要注意的地方"></a>使用handler需要注意的地方</h3><p>1、从looper的源码中可以知道，每个线程只能有一个looper，也就是不能在同一个线程中多次调用prepare方法。<br>2、在子线程中使用handler，要按Looper.prepare,new handler,looper.loop顺序调用，其中原理已经分析过了<br>3、使用handler时要注意内存泄露。当消息队列中还有待处理的消息时，如果aty被销毁，因为消息中持有aty实例，导致内存泄露。此时我们可以采用静态内部类+对aty的弱引用解决。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/01/深入理解Handler/" data-id="cj597eiz3002j9ux3acgq6jdt" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/handler/">handler</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-Looper" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/01/Looper/" class="article-date">
  <time class="post-time" datetime="2016-11-01T08:41:40.000Z" itemprop="datePublished">
    <span class="post-month">11月</span><br/>
    <span class="post-day">01</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/01/Looper/">Looper</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/android/">android</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Looper这个类的主要功能是做消息的分发，并没有很复杂的逻辑</p>
<h2 id="Looper类关键属性"><a href="#Looper类关键属性" class="headerlink" title="Looper类关键属性"></a>Looper类关键属性</h2><p><img src="http://ofy9dm2ii.bkt.clouddn.com/image/article/looper.png" alt="looper属性"></p>
<h2 id="Looper类关键方法"><a href="#Looper类关键方法" class="headerlink" title="Looper类关键方法"></a>Looper类关键方法</h2><h6 id="1、创建Looper"><a href="#1、创建Looper" class="headerlink" title="1、创建Looper"></a>1、创建Looper</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</div><div class="line">        &#125;</div><div class="line">        sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</div><div class="line">    &#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</div><div class="line">    prepare(<span class="keyword">false</span>);</div><div class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</div><div class="line">        <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</div><div class="line">        &#125;</div><div class="line">        sMainLooper = myLooper();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这两个方法都是创建looper的方法，第一个是在一般线程中创建使用，第二个是创建mainLooper的时候调用。<br>主要区别在于quitAllowed参数，第一个方法默认接收的是true，表示此looper关联的MessageQueue允许停止，而mainLooper关联的MessageQueue是不允许停止的。从方法的实现可以看出，每个线程只允许一个Looper的存在。</p>
<p>######2、遍历取消息<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Looper me = myLooper();</div><div class="line">        <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">final</span> MessageQueue queue = me.mQueue;</div><div class="line"></div><div class="line">        <span class="comment">// Make sure the identity of this thread is that of the local process,</span></div><div class="line">        <span class="comment">// and keep track of what that identity token actually is.</span></div><div class="line">        Binder.clearCallingIdentity();</div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            Message msg = queue.next(); <span class="comment">// might block</span></div><div class="line">            <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// No message indicates that the message queue is quitting.</span></div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></div><div class="line">            <span class="keyword">final</span> Printer logging = me.mLogging;</div><div class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</div><div class="line">                logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</div><div class="line">                        msg.callback + <span class="string">": "</span> + msg.what);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">final</span> <span class="keyword">long</span> traceTag = me.mTraceTag;</div><div class="line">            <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</div><div class="line">                Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                msg.target.dispatchMessage(msg);</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</div><div class="line">                    Trace.traceEnd(traceTag);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</div><div class="line">                logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Make sure that during the course of dispatching the</span></div><div class="line">            <span class="comment">// identity of the thread wasn't corrupted.</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</div><div class="line">            <span class="keyword">if</span> (ident != newIdent) &#123;</div><div class="line">                Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span></div><div class="line">                        + Long.toHexString(ident) + <span class="string">" to 0x"</span></div><div class="line">                        + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></div><div class="line">                        + msg.target.getClass().getName() + <span class="string">" "</span></div><div class="line">                        + msg.callback + <span class="string">" what="</span> + msg.what);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            msg.recycleUnchecked();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>下面就来分析下这个方法做的事情：<br>首先第二行是获取当前线程的Looper实例，接着是在looper中获取MessageQueue。下面这两行就如注释所说，保证当前线程是在本地运行并持续跟踪。具体想了解其中原理和机制可以<a href="http://www.th7.cn/Program/java/201603/774109.shtml" target="_blank" rel="external">点这里查看</a>，这两行不理解，并不耽误整体流程的理解。<br>接下来就是进入一个死循环，循环中不断的从queue中取出消息，然后验证消息的各种属性，判断是否是一个有效的消息。其中有一行msg.target.dispatchMessage(msg);这行代码的意思就是把消息分发出去，最后让属于此msg的handler来处理。最后，会调用msg.recycleUnchecked();如果看了Message这个类，可以知道，这个方法就是对消息重新初始化，然后扔进复用池，而且在这里调用的是强制回收方法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/01/Looper/" data-id="cj597eixf000i9ux3j8u5845u" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/handler/">handler</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-MessageQueue" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/01/MessageQueue/" class="article-date">
  <time class="post-time" datetime="2016-11-01T08:36:38.000Z" itemprop="datePublished">
    <span class="post-month">11月</span><br/>
    <span class="post-day">01</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/01/MessageQueue/">MessageQueue</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/android/">android</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>MessageQueue的作用是操作message，因为message本身就是链表结构，所以MessageQueue不必用LinkList之类的数据结构存储msg。只需要持有一个message实例就行了。此方法中有许多native方法，不过多分析。主要分析几个关键的方法，有助于理解MessageQueue是如何管理msg的。</p>
<h2 id="关键方法"><a href="#关键方法" class="headerlink" title="关键方法"></a>关键方法</h2><h4 id="1、初始化"><a href="#1、初始化" class="headerlink" title="1、初始化"></a>1、初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">MessageQueue(<span class="keyword">boolean</span> quitAllowed) &#123;</div><div class="line">        mQuitAllowed = quitAllowed;</div><div class="line">        mPtr = nativeInit();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>初始化很简单，mPtr相当于一个指针，指向nativeInit（）方法返回的东西，那么就看一下nativeInit（）的实现<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_os_MessageQueue_nativeInit</span><span class="params">(JNIEnv* env, jclass clazz)</span> </span>&#123;</div><div class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">new</span> NativeMessageQueue();</div><div class="line">    <span class="keyword">if</span> (!nativeMessageQueue) &#123;</div><div class="line">        jniThrowRuntimeException(env, <span class="string">"Unable to allocate native queue"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">NativeMessageQueue::NativeMessageQueue() :</div><div class="line">        mPollEnv(<span class="literal">NULL</span>), mPollObj(<span class="literal">NULL</span>), mExceptionObj(<span class="literal">NULL</span>) &#123;</div><div class="line">    mLooper = Looper::getForThread();</div><div class="line">    <span class="keyword">if</span> (mLooper == <span class="literal">NULL</span>) &#123;</div><div class="line">        mLooper = <span class="keyword">new</span> Looper(<span class="literal">false</span>);</div><div class="line">        Looper::setForThread(mLooper);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">    jfieldID mPtr;   <span class="comment">// native object attached to the DVM MessageQueue</span></div><div class="line">    jmethodID dispatchEvents;</div><div class="line">&#125; gMessageQueueClassInfo;</div></pre></td></tr></table></figure></p>
<p>可以看到，原来native层也有一个MessageQueue类，java层MessageQueue的mPtr就是指向native层的MessageQueue对象。native层的结构体中的变量mPtr指向java的Mess对象，这样，java层和native层就关联起来了。同时又可以看到，native层也有Looper对象，也是保存在当前线程的。看下native层Looper的创建方法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Looper::Looper(<span class="keyword">bool</span> allowNonCallbacks) :</div><div class="line">        mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(<span class="literal">false</span>),</div><div class="line">        mPolling(<span class="literal">false</span>), mEpollFd(<span class="number">-1</span>), mEpollRebuildRequired(<span class="literal">false</span>),</div><div class="line">        mNextRequestSeq(<span class="number">0</span>), mResponseIndex(<span class="number">0</span>), mNextMessageUptime(LLONG_MAX) &#123;</div><div class="line">    mWakeEventFd = eventfd(<span class="number">0</span>, EFD_NONBLOCK);</div><div class="line">    LOG_ALWAYS_FATAL_IF(mWakeEventFd &lt; <span class="number">0</span>, <span class="string">"Could not make wake event fd.  errno=%d"</span>, errno);</div><div class="line"></div><div class="line">    AutoMutex _l(mLock);</div><div class="line">    rebuildEpollLocked();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中第5行很重要，保存对管道的读写描述符，然后创建一个epoll实例。<br>也就是说，java层和native层的Looper和MessageQueue是一一对应，协同工作的，创建顺序是java:Looper-&gt;java:MessageQueue-&gt;native:MessageQueue-&gt;native:Looper</p>
<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>在消息循环过程中，如果没有新的消息要处理，线程就会睡眠在管道的读端文件描述符上，直到有消息处理为止；当其他线程向这个线程发送消息的时候，其他线程就会通过这个管道的写端文件描述符写数据从而将线程唤醒。epoll机制就是为了同时监听多个文件描述符的IO读写时间而设计的，它是一个多路复用的IO接口。类似于Linux的select机制。select就是监听众多的文件描述符接口，但是每次发生事件，它都要遍历所有的监听，找到匹配的发送事件。epoll则是select的加强版，在监听大量IO读写，但只有少量是活跃的时候，能显著减少cpu使用率。<a href="http://blog.csdn.net/xiajun07061225/article/details/9250579" target="_blank" rel="external">关于epoll机制的详细信息和实现</a></p>
<h4 id="2、取消息"><a href="#2、取消息" class="headerlink" title="2、取消息"></a>2、取消息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="comment">// Return here if the message loop has already quit and been disposed.</span></div><div class="line">       <span class="comment">// This can happen if the application tries to restart a looper after quit</span></div><div class="line">       <span class="comment">// which is not supported.</span></div><div class="line">       <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</div><div class="line">       <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></div><div class="line">       <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</div><div class="line">       <span class="keyword">for</span> (;;) &#123;</div><div class="line">           <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</div><div class="line">               Binder.flushPendingCommands();</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           nativePollOnce(ptr, nextPollTimeoutMillis);</div><div class="line"></div><div class="line">           <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">               <span class="comment">// Try to retrieve the next message.  Return if found.</span></div><div class="line">               <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</div><div class="line">               Message prevMsg = <span class="keyword">null</span>;</div><div class="line">               Message msg = mMessages;</div><div class="line">               <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</div><div class="line">                   <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></div><div class="line">                   <span class="keyword">do</span> &#123;</div><div class="line">                       prevMsg = msg;</div><div class="line">                       msg = msg.next;</div><div class="line">                   &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</div><div class="line">                   <span class="keyword">if</span> (now &lt; msg.when) &#123;</div><div class="line">                       <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></div><div class="line">                       nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</div><div class="line">                   &#125; <span class="keyword">else</span> &#123;</div><div class="line">                       <span class="comment">// Got a message.</span></div><div class="line">                       mBlocked = <span class="keyword">false</span>;</div><div class="line">                       <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</div><div class="line">                           prevMsg.next = msg.next;</div><div class="line">                       &#125; <span class="keyword">else</span> &#123;</div><div class="line">                           mMessages = msg.next;</div><div class="line">                       &#125;</div><div class="line">                       msg.next = <span class="keyword">null</span>;</div><div class="line">                       <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Returning message: "</span> + msg);</div><div class="line">                       msg.markInUse();</div><div class="line">                       <span class="keyword">return</span> msg;</div><div class="line">                   &#125;</div><div class="line">               &#125; <span class="keyword">else</span> &#123;</div><div class="line">                   <span class="comment">// No more messages.</span></div><div class="line">                   nextPollTimeoutMillis = -<span class="number">1</span>;</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               <span class="comment">// Process the quit message now that all pending messages have been handled.</span></div><div class="line">               <span class="keyword">if</span> (mQuitting) &#123;</div><div class="line">                   dispose();</div><div class="line">                   <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               <span class="comment">// If first time idle, then get the number of idlers to run.</span></div><div class="line">               <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></div><div class="line">               <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></div><div class="line">               <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></div><div class="line">                       &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</div><div class="line">                   pendingIdleHandlerCount = mIdleHandlers.size();</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</div><div class="line">                   <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></div><div class="line">                   mBlocked = <span class="keyword">true</span>;</div><div class="line">                   <span class="keyword">continue</span>;</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</div><div class="line">                   mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</div><div class="line">               &#125;</div><div class="line">               mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="comment">// Run the idle handlers.</span></div><div class="line">           <span class="comment">// We only ever reach this code block during the first iteration.</span></div><div class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</div><div class="line">               <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</div><div class="line">               mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></div><div class="line"></div><div class="line">               <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</div><div class="line">               <span class="keyword">try</span> &#123;</div><div class="line">                   keep = idler.queueIdle();</div><div class="line">               &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">                   Log.wtf(TAG, <span class="string">"IdleHandler threw exception"</span>, t);</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               <span class="keyword">if</span> (!keep) &#123;</div><div class="line">                   <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">                       mIdleHandlers.remove(idler);</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></div><div class="line">           pendingIdleHandlerCount = <span class="number">0</span>;</div><div class="line"></div><div class="line">           <span class="comment">// While calling an idle handler, a new message could have been delivered</span></div><div class="line">           <span class="comment">// so go back and look again for a pending message without waiting.</span></div><div class="line">           nextPollTimeoutMillis = <span class="number">0</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h5 id="普通消息"><a href="#普通消息" class="headerlink" title="普通消息"></a>普通消息</h5><p>第5行，mPtr指向native中的MessageQueue，是java层和native联系的纽带。第11行变量nextPollTimeoutMillis是设置休眠时间的：如果赋值为0，则表示无论消息队列中是否有消息，线程都不进入休眠状态，如果赋值为-1，则表示无论什么情况，线程都进入休眠状态。接下来就进入消息循环中了，看13行，如果此时线程需要进入休眠状态，那么，就执行Binder.flushPendingCommands();sdk的解释为：Flush any Binder commands pending in the current thread to the kernel driver.  This can be useful to call before performing an operation that may block for a long time, to ensure that any pending object references have been released in order to prevent the process from holding on to objects longer than it needs to.大意就是执行binder通信请求，防止等待时间过长。接下来就是调用nativa方法nativePollOnce<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//MessageQueue</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativePollOnce</span><span class="params">(JNIEnv* env, jobject obj,</span></span></div><div class="line">        jlong ptr, jint timeoutMillis) &#123;</div><div class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</div><div class="line">    nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//MessageQueue</span></div><div class="line"><span class="keyword">void</span> NativeMessageQueue::pollOnce(JNIEnv* env, jobject pollObj, <span class="keyword">int</span> timeoutMillis) &#123;</div><div class="line">    mPollEnv = env;</div><div class="line">    mPollObj = pollObj;</div><div class="line">    mLooper-&gt;pollOnce(timeoutMillis);</div><div class="line">    mPollObj = <span class="literal">NULL</span>;</div><div class="line">    mPollEnv = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (mExceptionObj) &#123;</div><div class="line">        env-&gt;Throw(mExceptionObj);</div><div class="line">        env-&gt;DeleteLocalRef(mExceptionObj);</div><div class="line">        mExceptionObj = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//Looper</span></div><div class="line"><span class="keyword">int</span> Looper::pollOnce(<span class="keyword">int</span> timeoutMillis, <span class="keyword">int</span>* outFd, <span class="keyword">int</span>* outEvents, <span class="keyword">void</span>** outData) &#123;</div><div class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">while</span> (mResponseIndex &lt; mResponses.size()) &#123;</div><div class="line">            <span class="keyword">const</span> Response&amp; response = mResponses.itemAt(mResponseIndex++);</div><div class="line">            <span class="keyword">int</span> ident = response.request.ident;</div><div class="line">            <span class="keyword">if</span> (ident &gt;= <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">int</span> fd = response.request.fd;</div><div class="line">                <span class="keyword">int</span> events = response.events;</div><div class="line">                <span class="keyword">void</span>* data = response.request.data;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_POLL_AND_WAKE</span></div><div class="line">                ALOGD(<span class="string">"%p ~ pollOnce - returning signalled identifier %d: "</span></div><div class="line">                        <span class="string">"fd=%d, events=0x%x, data=%p"</span>,</div><div class="line">                        <span class="keyword">this</span>, ident, fd, events, data);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">                <span class="keyword">if</span> (outFd != <span class="literal">NULL</span>) *outFd = fd;</div><div class="line">                <span class="keyword">if</span> (outEvents != <span class="literal">NULL</span>) *outEvents = events;</div><div class="line">                <span class="keyword">if</span> (outData != <span class="literal">NULL</span>) *outData = data;</div><div class="line">                <span class="keyword">return</span> ident;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_POLL_AND_WAKE</span></div><div class="line">            ALOGD(<span class="string">"%p ~ pollOnce - returning result %d"</span>, <span class="keyword">this</span>, result);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">            <span class="keyword">if</span> (outFd != <span class="literal">NULL</span>) *outFd = <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span> (outEvents != <span class="literal">NULL</span>) *outEvents = <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span> (outData != <span class="literal">NULL</span>) *outData = <span class="literal">NULL</span>;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        result = pollInner(timeoutMillis);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先看第4行，前面说过，java层的mPtr就是指向native层MessageQueue的指针，此处创建了一个native层的MessageQueue的指针，并且把mPtr赋值给它，那么它此时代表的就是native层与java层绑定的MessageQueue对象。<br>然后调用这个对象的pollOnce方法去取消息。然后看到第12行，pollOnce方法里其实是调用了native层的Looper实例的pollOnce方法去取消息。接下来就可以看到Looper的pollOnce方法了，首先在while循环中，经过各种条件的判断，如果有新消息，那么就返回。（中间各种epoll相关各种赋值不做研究）如果没有新消息，那么就调用pollInner方法，这个方法比较长，也是各种epoll的操作，不做分析，主要作用就是监听管道的读写时间，从而使线程能从休眠中唤醒或者进入休眠状态。<br>接下来，如果在native层中拿到了消息，那么java层的mMessage成员变量就不为空，24-30行则是从消息队列中取出一个非同步消息。32行是判断此消息是否需要立即处理，如果不需要，则设置等待时间，如果需要，进入else，else中有个mBlocked变量，它的作用是标记线程是否处于阻塞状态。那么当mMessage为空的时候，则nextPollTimeoutMillis为-1，表示进入休眠。</p>
<h5 id="特殊消息"><a href="#特殊消息" class="headerlink" title="特殊消息"></a>特殊消息</h5><p>IdleHandler表示一种特殊的消息。这种消息会在线程空闲的时候被处理，能充分利用cup空闲时间。只要实现了IdleHandler接口，就可以被注册到空闲消息列表。<br>第10行pendingIdleHandlerCount表示的是注册到空闲消息列表的消息处理器的个数，这里赋值为-1。然后看到62行，因为pendingIdleHandlerCount初始值为-1，所以当没有消息，或者消息时间大于当前时间的时候满足条件，此时如果空闲消息列表有事件，则会在80出执行，如果没有事件，则在66行处让线程休眠。如果有空闲事件，执行完之后，在99行会重新给pendingIdleHandlerCount赋值为0.作用就是每次进入next方法后，之后执行一次空闲消息，后期线程被唤醒，继续消息循环，不会执行空闲消息。我们还可以看到在103行给nextPollTimeoutMillis 赋值为0.应为在处理空闲消息的时候，有可能有新的消息发来，所以当再次调用nextPollTimeoutMillis的时候不会进入休眠状态。</p>
<h4 id="2、存消息"><a href="#2、存消息" class="headerlink" title="2、存消息"></a>2、存消息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (msg.isInUse()) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (mQuitting) &#123;</div><div class="line">                IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</div><div class="line">                        msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</div><div class="line">                Log.w(TAG, e.getMessage(), e);</div><div class="line">                msg.recycle();</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            msg.markInUse();</div><div class="line">            msg.when = when;</div><div class="line">            Message p = mMessages;</div><div class="line">            <span class="keyword">boolean</span> needWake;</div><div class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</div><div class="line">                <span class="comment">// New head, wake up the event queue if blocked.</span></div><div class="line">                msg.next = p;</div><div class="line">                mMessages = msg;</div><div class="line">                needWake = mBlocked;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// Inserted within the middle of the queue.  Usually we don't have to wake</span></div><div class="line">                <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></div><div class="line">                <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></div><div class="line">                needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</div><div class="line">                Message prev;</div><div class="line">                <span class="keyword">for</span> (;;) &#123;</div><div class="line">                    prev = p;</div><div class="line">                    p = p.next;</div><div class="line">                    <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class="line">                        needWake = <span class="keyword">false</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                msg.next = p; <span class="comment">// invariant: p == prev.next</span></div><div class="line">                prev.next = msg;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></div><div class="line">            <span class="keyword">if</span> (needWake) &#123;</div><div class="line">                nativeWake(mPtr);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>把消息加入到消息队列的逻辑相对简单，我们从27行看起，if的条件是新加入的消息目标时间小于消息队列的队头消息，则把当前消息放入队头。否则的话进入else，else的for循环是为了寻找和新消息的目标时间最相近的消息，然后把消息插入到队列中去。当我们把消息放在队头的时候，如果此时为阻塞状态，那么肯定需要唤醒线程，告诉它有新消息，也就是needWake =mBlocked;当插入到队中的时候，一般不需要唤醒线程，只有在线程是阻塞状态，并且我们插入的消息是队列中第一个异步消息。也即是 needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/01/MessageQueue/" data-id="cj597eixj000n9ux3xkl4ltm0" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/handler/">handler</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-Message" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/01/Message/" class="article-date">
  <time class="post-time" datetime="2016-11-01T07:10:26.000Z" itemprop="datePublished">
    <span class="post-month">11月</span><br/>
    <span class="post-day">01</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/01/Message/">Message</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/android/">android</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="Message类关键属性"><a href="#Message类关键属性" class="headerlink" title="Message类关键属性"></a>Message类关键属性</h4><p><img src="http://ofy9dm2ii.bkt.clouddn.com/image/article/message.jpeg" alt="message属性"></p>
<h4 id="Message类关键方法"><a href="#Message类关键方法" class="headerlink" title="Message类关键方法"></a>Message类关键方法</h4><h6 id="1、获取消息"><a href="#1、获取消息" class="headerlink" title="1、获取消息"></a>1、获取消息</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (sPoolSync) &#123;</div><div class="line">            <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</div><div class="line">                Message m = sPool;</div><div class="line">                sPool = m.next;</div><div class="line">                m.next = <span class="keyword">null</span>;</div><div class="line">                m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></div><div class="line">                sPoolSize--;</div><div class="line">                <span class="keyword">return</span> m;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Message();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>因为Message采用链表的形式存储消息，当我们用obtaion获取消息实例的时候，首先就是遍历消息链表，如果链表中有消息实例，则直接返回，如果没有，则new一个出来，下面这些方法，都是首先调用obtain获取一个消息，然后把带来的参数赋给获取的实例</p>
<h6 id="2、获取消息重载方法"><a href="#2、获取消息重载方法" class="headerlink" title="2、获取消息重载方法"></a>2、获取消息重载方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Message orig)</span></span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h)</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h, Runnable callback)</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h, <span class="keyword">int</span> what)</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h, <span class="keyword">int</span> what, Object obj)</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h, <span class="keyword">int</span> what, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span></div></pre></td></tr></table></figure>
<h6 id="3、回收消息"><a href="#3、回收消息" class="headerlink" title="3、回收消息"></a>3、回收消息</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// Mark the message as in use while it remains in the recycled object pool.</span></div><div class="line">        <span class="comment">// Clear out all other details.</span></div><div class="line">        flags = FLAG_IN_USE;</div><div class="line">        what = <span class="number">0</span>;</div><div class="line">        arg1 = <span class="number">0</span>;</div><div class="line">        arg2 = <span class="number">0</span>;</div><div class="line">        obj = <span class="keyword">null</span>;</div><div class="line">        replyTo = <span class="keyword">null</span>;</div><div class="line">        sendingUid = -<span class="number">1</span>;</div><div class="line">        when = <span class="number">0</span>;</div><div class="line">        target = <span class="keyword">null</span>;</div><div class="line">        callback = <span class="keyword">null</span>;</div><div class="line">        data = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span> (sPoolSync) &#123;</div><div class="line">            <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</div><div class="line">                next = sPool;</div><div class="line">                sPool = <span class="keyword">this</span>;</div><div class="line">                sPoolSize++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个方法写的很明白，就是把当前消息的属性重新初始化，然后放进复用池</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/01/Message/" data-id="cj597eixe000e9ux3mlcp3huy" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/handler/">handler</a></li></ul>

    </footer>
  </div>
  
</article>




  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; pre</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>
</section>
        
          <aside id="sidebar">
  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <h1 class="blog-title">逝去的美好</h1>
    <h2 class="blog-subtitle">null</h2>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://avatars0.githubusercontent.com/u/20333903?v=3&amp;s=460">
    <h2 class="author">geekzw</h2>
    <h3 class="description">null</h3>
    <div class="count-box">
      <a href="/archives"><div><strong>30</strong><br>文章</div></a>
      <a href="/categories"><div><strong>7</strong><br>分类</div></a>
      <a href="/tags"><div><strong>6</strong><br>标签</div></a>
    </div>



    <div class="social-link">
      
        <a class="hvr-bounce-in" href="http://github.com/ShanaMaid" target="_blank" title="Github">
          Github
        </a>
      
    </div>

    <div class="friend-link">
      <h2>友情链接</h2>
      
        <a class="hvr-bounce-in" href="http://blog.shanamaid.top/" target="_blank" title="ShanaMaid">
          ShanaMaid
        </a>
      
    </div>
  </div>
</div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy;2016 - 2017 geekzw<br>
      由<a href="http://hexo.io/" target="_blank">Hexo</a>强力驱动 | 
      主题-<a href="https://github.com/ShanaMaid/hexo-theme-shana">Shana</a>
      
    </div>
    
  </div>
</footer>
    </div>
    

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="//apps.bdimg.com/libs/wow/0.1.6/wow.min.js"></script>
<script>
new WOW().init();
</script>   


  <link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">
  <script src="/plugin/fancybox/jquery.fancybox.pack.js"></script>



  <link rel="stylesheet" href="/plugin/galmenu/GalMenu.css">
  <script src="/plugin/galmenu/GalMenu.js"></script>
  <div class="GalMenu GalDropDown">
      <div class="circle" id="gal">
        <div class="ring">
          
            <a href="/" title="" class="menuItem">首页</a>
          
            <a href="/tags" title="" class="menuItem">标签</a>
          
            <a href="/categories" title="" class="menuItem">分类</a>
          
            <a href="/archives" title="" class="menuItem">归档</a>
          
            <a href="/xxxxxxxxx" title="" class="menuItem">xxx</a>
          
            <a href="/xxxxxxx" title="" class="menuItem">xxxx</a>
          
        </div>
        
          <audio id="audio" src="#"></audio>
        
      </div> 
</div>
<div id="overlay" style="opacity: 1; cursor: pointer;"></div>
  <script type="text/javascript">var items = document.querySelectorAll('.menuItem');
    for (var i = 0,
    l = items.length; i < l; i++) {
      items[i].style.left = (50 - 35 * Math.cos( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%";
      items[i].style.top = (50 + 35 * Math.sin( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%"
    }</script>
<script type="text/javascript">
  $(document).ready(function() {
    $('body').GalMenu({
      'menu': 'GalDropDown'
    })
  });
</script>

  <section class="hidden-xs"> 
  <ul class="cb-slideshow"> 
    <li><span>苟利</span></li> 
    <li><span>国家</span></li> 
    <li><span>生死以</span></li> 
    <li><span>岂能</span></li> 
    <li><span>祸福</span></li> 
    <li><span>趋避之</span></li> 
  </ul>
</section>
<script src="/js/script.js"></script>



  </div>
</body>
</html>