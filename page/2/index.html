<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>逝去的美好</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="逝去的美好">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="逝去的美好">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="逝去的美好">
  
    <link rel="alternate" href="/atom.xml" title="逝去的美好" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/plugin/bganimation/bg.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <div class="widget-wrap mobile-header">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://avatars0.githubusercontent.com/u/20333903?v=3&amp;s=460">
    <h2 class="author">geekzw</h2>
    <h3 class="description">null</h3>
    <div class="count-box">
      <a href="/archives"><div><strong>30</strong><br>文章</div></a>
      <a href="/categories"><div><strong>7</strong><br>分类</div></a>
      <a href="/tags"><div><strong>6</strong><br>标签</div></a>
    </div>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

        <section id="main">
  
    <article id="post-Hexo" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/09/Hexo/" class="article-date">
  <time class="post-time" datetime="2016-12-09T06:12:34.000Z" itemprop="datePublished">
    <span class="post-month">12月</span><br/>
    <span class="post-day">09</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/09/Hexo/">Hexo</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/hexo/">hexo</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>搭建Hexo+git的个人博客：<a href="http://www.jianshu.com/p/05289a4bc8b2" target="_blank" rel="external">http://www.jianshu.com/p/05289a4bc8b2</a></p>
<p>Next使用文档：<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="external">http://theme-next.iissnan.com/getting-started.html</a></p>
<p>Next主题配置：<a href="http://theme-next.iissnan.com/theme-settings.html#author-sites" target="_blank" rel="external">http://theme-next.iissnan.com/theme-settings.html#author-sites</a></p>
<p>Next主题常见问题：<a href="http://theme-next.iissnan.com/faqs.html" target="_blank" rel="external">http://theme-next.iissnan.com/faqs.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/09/Hexo/" data-id="cj597kuj00006b1x34ukpue7e" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hexo/">hexo</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-Floyd" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/09/Floyd/" class="article-date">
  <time class="post-time" datetime="2016-12-09T04:36:29.000Z" itemprop="datePublished">
    <span class="post-month">12月</span><br/>
    <span class="post-day">09</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/09/Floyd/">Floyd</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/algorithm/">algorithm</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Floyd概述"><a href="#Floyd概述" class="headerlink" title="Floyd概述"></a>Floyd概述</h2><p>Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>floyd算法里面实际用了动态规划的思想。我们先想想动态规划思想。</p>
<ul>
<li>目标问题可以划分成众多相同的子问题</li>
<li>子问题具有重叠性，子问题的解对进一步求目标问题有帮助<br>那么现在再来思考下floyd是怎么做的。假如求u到v的最短路径。第一种方法是求u到v的直接路径。第二种是间接路径，就是说可以通过其他路径例如i到v，这样最终路径就是（u,i）+(i,v)。这情况就多了，因为i可以是其他任意一条路径，也可以多条路径。这个时候就需要划分问题了。我们可以先算出经过1个点的路径，再算出经过2个点的路径。。。。。。下面就通过图，具体分析一个问题<br><img src="http://ofy9dm2ii.bkt.clouddn.com/image/article/floyd.png" alt="floyd"><br>如图，我们第一步要做的，就是上面的第一种情况，先无脑的保存任意两点的距离，不直接相连的，就是无穷大。比如1-&gt;2 = 2;1-&gt;3 = 6;1-&gt;5 = 无穷大。这是直接相连情况。如果可以经过中间点，那么问题立马就复杂了（因为中间节点可以是任意一个，也可以是多个）。这个时候就拆分子问题。例如，我开始只让经过2号节点，那么现在就可以计算出，任意两点相连，是直接连短，还是经过2转折一下短。比如1-&gt;3。<br>原来最短距离就是直接相连为6，那么如果可以经过2，就变成了(1,2)+(2,3)和(1,3)这两条路了，显然经过2节点这条路更近一些，那么就更新(1,3)的距离为5。这里就是dp思想中的划分子问题，求出子问题的解。当我们再开放3节点的时候。也就是可以经过3这个节点。原来1-&gt;5距离是无穷大，因为没有直接相连，通过2也不能到达。现在放开3节点了。那么我们就可以通过(1,3,5)和(1,2,3,5)两条路到达5了，那么哪条更近啊，显然是(1,2,3,5)啊，因为里面公共部分是(3,5)，前面有分析过了(1,2,3)比(1,3)这条路近，所以(1,5)的距离就可以更新为(1,2,3,5)这条路的距离了。这里发现没，我们用到的还是dp思想，前面是说划分子问题，然后扩大规模。现在是子问题的求解对目标问题有帮助，前一个子问题计算出了(1,3)的最短距离，现在就可以拿来用了。否则，还是要比较一遍(1,2,3)和(1,3)谁短，这就是dp说的子问题的重叠。后面的就是老套路了，不停的开放新节点，计算加入新节点后的两点间的最短路。其实说是解释floyd，倒是把dp解释了一遍，dp说完，floyd算法自然也就有了。下面给出核心算法，简单到吓你一跳<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=n;k++)<span class="comment">//新开允许路过的节点 </span></div><div class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//新开节点后任意节点A </span></div><div class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)<span class="comment">//新开节点后任意节点B</span></div><div class="line">            <span class="keyword">if</span>(e[i][j]&gt;e[i][k]+e[k][j])<span class="comment">//判断通过新开节点(A,B)距离会不会变短  </span></div><div class="line">            e[i][j]=e[i][k]+e[k][j];</div></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/09/Floyd/" data-id="cj597kuip0002b1x3f8bbpwrb" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/">algorithm</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-Dijkstra" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/08/Dijkstra/" class="article-date">
  <time class="post-time" datetime="2016-12-08T02:46:37.000Z" itemprop="datePublished">
    <span class="post-month">12月</span><br/>
    <span class="post-day">08</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/08/Dijkstra/">Dijkstra</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/algorithm/">algorithm</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="废话"><a href="#废话" class="headerlink" title="废话"></a>废话</h2><p>今天看了Dijkstra算法，花了些时间，也总算是理解了，特此写下，方便以后回忆。感觉算法这东西，长时间不看，容易忘。当然网上这类博客也很多，其中也有些讲的很好。之所以自己写，是因为自己理解的思路，总归是有些自己的特点，如果每次都去看别人的，每次都要按别人的套路走一遍。而回过头看自己的话，估计浏览一遍就能回忆起来。我只能说写给自己以后温习用，因为自己理解不够深，文采又没有，不敢说写给广大人民群众看，当然，如果你看完后对你有点帮助那就再好不过了。废话不多说了，开始。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Dijkstra解决的是单源最短路径问题，也就是图中某个点到其他任意点的最短路径，权值要求是正值。</p>
<h2 id="讲故事"><a href="#讲故事" class="headerlink" title="讲故事"></a>讲故事</h2><p><img src="http://ofy9dm2ii.bkt.clouddn.com/Dijkstra.png" alt="此处输入图片的描述"><br>看这图是不是很简单？简单就对了，简单能说明问题的话，干嘛搞个很复杂的图。Dijkstra的思想有些像广搜，地毯式搜索，每次只找离自己最近的节点。我们可以这么想，比如我要找1到4的最短路。那么1就可以看成一个公司的boss，现在公司就他一个人。我们看到2和3与他相连，说明他认识2和3，2和3跟他的距离（权值）也就是跟他的亲密度。这时候，如果1想拉人入伙，我们想想他会找谁，肯定找3啊，因为3跟他关系好啊。那么也就是说，1节点首先找到离他最近的节点，那就是3.然后3入伙了，也就近了公司这个集合。1就说了，公司需要扩大规模，你快去发展下线（招人去吧）。然后就把招人的事交给3了，从图中我们可以看出，3只认识4了，所以就去找4，找到后跟1汇报，并说明了他跟4的关系，权值是10（看来关系有点远了）。这个时候，1想了，我不是还认识2吗，相比4，跟2的关系更好啊。于是，1又找到跟他关系最好的（距离最近），因为这个时候3已经加入了公司，所以不考虑了。所以就只能是2了。2加入后跟3做同样的事，去招人。巧了，2也认识4，并且跟4的关系看上去还不错奥。这个时候它再向1汇报，说自己找到了4，并且说明跟4的关系。这个时候注意，前面忘记交代，当3找到4并向1汇报的时候，1综合他跟3的关系，再加上3跟4的关系，已经能得出跟4的关系值了（距离），当时就是因为不太满意，感觉不可信，他才先就近找2.现在2也找到了4，并且关系又近了不少，1更新完跟4的关系值后，感觉还行，最后把4也收下了，这样，所有人都进入了公司，并且跟1的关系很明确了。</p>
<p>##故事&amp;Dijkstra<br>读完故事，我们能得到这些信息</p>
<ul>
<li>boss(源点)每次都是找离他最近的人（节点）</li>
<li>找到节点后让他去招人（更新与最近节点相连的节点信息）<br>其实主要就是这两点了，不断循环往复，所有节点都会被找到，所有节点距源点的距离也变成了最短距离，因为源点每次派出去的都是据他最近的点。<br>##代码<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dijkstra</span> </span>&#123;</div><div class="line">    <span class="comment">//这里主要做初始化工作</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> count;<span class="comment">//节点数</span></div><div class="line">        <span class="keyword">int</span> pathCount;<span class="comment">//路径数</span></div><div class="line">        Scanner scanner=<span class="keyword">new</span> Scanner(System.in);</div><div class="line">        count = scanner.nextInt();</div><div class="line">        pathCount = scanner.nextInt();</div><div class="line">        <span class="keyword">int</span>[][] array = <span class="keyword">new</span> <span class="keyword">int</span>[count+<span class="number">1</span>][count+<span class="number">1</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count+<span class="number">1</span>;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;count+<span class="number">1</span>;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(i == j)array[i][j] = <span class="number">0</span>;</div><div class="line">                <span class="keyword">else</span> array[i][j] = Integer.MAX_VALUE;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pathCount;i++)&#123;</div><div class="line">            <span class="keyword">int</span> a = scanner.nextInt();</div><div class="line">            <span class="keyword">int</span> b = scanner.nextInt();</div><div class="line">            <span class="keyword">int</span> c = scanner.nextInt();</div><div class="line">            array[a][b] = c;</div><div class="line">        &#125;</div><div class="line">        System.out.print(dijkstra(array,<span class="number">1</span>,<span class="number">5</span>)+<span class="string">""</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//核心方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span>[][] array,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> length = array.length;</div><div class="line">        <span class="keyword">int</span>[] dis = <span class="keyword">new</span> <span class="keyword">int</span>[length];<span class="comment">//源点到各节点的距离</span></div><div class="line">        <span class="keyword">boolean</span>[] vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[length];<span class="comment">//是否已经加入公司了</span></div><div class="line">        vis[start] = <span class="keyword">true</span>;<span class="comment">//开始只有boss在公司</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length;i++)&#123;<span class="comment">//boss先收集他认识的人</span></div><div class="line">            dis[i] = array[start][i];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//找他最信任的人</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i &lt; length;i++)&#123;</div><div class="line">            <span class="keyword">int</span> current = <span class="number">0</span>;</div><div class="line">            <span class="keyword">int</span> min = Integer.MAX_VALUE;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;length;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(!vis[j] &amp;&amp; dis[j]&lt;min)&#123;</div><div class="line">                    min = dis[j];</div><div class="line">                    current = j;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            vis[current] = <span class="keyword">true</span>;<span class="comment">//找到后这个人加入公司</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">1</span>;v&lt;length;v++)&#123;<span class="comment">//派去干活（招人）</span></div><div class="line">                <span class="keyword">if</span>(array[current][v]&lt;Integer.MAX_VALUE)&#123;</div><div class="line">                    dis[v] = dis[v] &gt; (array[current][v]+dis[current])?(array[current][v]+dis[current]):dis[v];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"><span class="comment">//        for(int i=1;i&lt;length;i++)&#123;</span></div><div class="line"><span class="comment">//            System.out.print(dis[i]+" ");</span></div><div class="line"><span class="comment">//        &#125;</span></div><div class="line">        <span class="keyword">return</span> dis[end];</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line">6 9</div><div class="line">1 2 7</div><div class="line">1 3 9</div><div class="line">1 6 14</div><div class="line">2 3 10</div><div class="line">3 6 2</div><div class="line">6 5 9</div><div class="line">2 4 15</div><div class="line">3 4 11</div><div class="line">4 5 6</div><div class="line"> */</div></pre></td></tr></table></figure>
</li>
</ul>
<p>代码关键地方依照故事情景写了注释，应该是能理解了，感觉自己写的好通俗，失去了算法那种高大上的感觉。不过我不care，能让我最快最容易理解的方法就是好方法，当然如果能帮到正在看的人，那就是更好的方法了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/08/Dijkstra/" data-id="cj597kuik0000b1x3rbdkie7y" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/">algorithm</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-android-常用小知识" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/06/android-常用小知识/" class="article-date">
  <time class="post-time" datetime="2016-12-06T03:13:28.000Z" itemprop="datePublished">
    <span class="post-month">12月</span><br/>
    <span class="post-day">06</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/06/android-常用小知识/">android 常用小知识</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/android/">android</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="阿里freeline"><a href="#阿里freeline" class="headerlink" title="阿里freeline"></a>阿里freeline</h2><p>加快编译速度，并打造动态热部署：<a href="https://github.com/alibaba/freeline" target="_blank" rel="external">freeline</a><br>test</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/06/android-常用小知识/" data-id="cj597kujw0010b1x3lh5d17ap" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-最长递增子序列（LIS）" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/06/最长递增子序列（LIS）/" class="article-date">
  <time class="post-time" datetime="2016-12-06T01:25:12.000Z" itemprop="datePublished">
    <span class="post-month">12月</span><br/>
    <span class="post-day">06</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/06/最长递增子序列（LIS）/">最长递增子序列（LIS）</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/algorithm/">algorithm</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="排序-最长公共子序列"><a href="#排序-最长公共子序列" class="headerlink" title="排序+最长公共子序列"></a>排序+最长公共子序列</h2><p>比如要找出ABDEC的最长子序列，我们可以先对这个串排序，排序后为ABCDE，此时找出两个串的最长公共子序列，即为ABDEC的最长递增子序列。<a href="https://geekzw.github.io/2016/12/05/最长递增子序列（LIS）/" target="_blank" rel="external">最长公共子序列</a>算法我在前面有写，可以参考一下。</p>
<h2 id="直接dp"><a href="#直接dp" class="headerlink" title="直接dp"></a>直接dp</h2><p>dp的两大规则，</p>
<ul>
<li>目标问题可以划分为相同的众多子问题</li>
<li>子问题具有重叠性，子问题对目标问题的求解有帮助<br>看我们这题目，显然满足。首先，我们求ABDEC的LIS的时候，我们可以先求出A子串的LIS，在A的基础上再求出AB的LIS，这样从子问题出发，问题规模不断扩大，最终求出目标问题的解。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LIS</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        String str = <span class="string">"ABDEC"</span>;</div><div class="line">        System.out.print(lis(str)+<span class="string">""</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lis</span><span class="params">(String str)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[str.length()+<span class="number">1</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dp.length;i++)&#123;</div><div class="line">            dp[i] = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</div><div class="line">                dp[i] = <span class="number">1</span>;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</div><div class="line">                    <span class="keyword">if</span>(str.charAt(i) &gt; str.charAt(j))&#123;</div><div class="line">                        dp[i] = dp[j]+<span class="number">1</span>;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dp[str.length()-<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>简单分析下代码。首先创建一个辅助数组，用来保存ABDEC串的每个位置的最大递增子序列。例如dp[0] = 1.因为只有A一个的时候，长度是1.dp<a href="https://geekzw.github.io/2016/12/05/最长递增子序列（LIS）/" target="_blank" rel="external">1</a> = 2;1这个位置对应的就是串的B，也就是走到B时的LIS，很明显B比A大，所以在B位置就是2，依次分析，就得出答案。每走到一个位置，让这个位置的数据跟在他之前的每一位进行比较，当找到第一个比他小的时候，他的长度就是那个比他小的的长度+1；</p>
<h2 id="最小末尾"><a href="#最小末尾" class="headerlink" title="最小末尾"></a>最小末尾</h2><p>这种方法肯定不是叫最小末尾，只是最小末尾是核心，就这么叫了。因为我们要找的是最长递增子序列，那么可以知道，子串的第二位肯定比第一位大，同样第三位肯定比第二位大。那么我们在第一位，肯定要放入一个最小的数字，如果放大了，那么可能存在比他小的，就没地方放了。就是在LIS的每一位，放入最小可能值。比如对1423这个序列。首先LIS的第一位肯定放1，然后第二位放4.当我们看到2的时候，2明显比4小啊，4放第二位就不合适了，那么就把4拿掉，2放第二位，看到3的时候，3比2大，所以放在第三位。又因为我们的辅助数组里按最小末尾放值，那么肯定是递增的，那么当我们拿到一个新的值，在辅助数组中替换某个最小末尾的时候，就可以用二分查找，节省时间<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lis2</span><span class="params">(String str)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> len = <span class="number">1</span>;</div><div class="line">        <span class="keyword">char</span>[] dp = <span class="keyword">new</span> <span class="keyword">char</span>[str.length()];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dp.length;i++)&#123;</div><div class="line">            dp[i] = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        dp[len] = str.charAt(<span class="number">0</span>);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;str.length();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(dp[len]&lt; str.charAt(i))&#123;</div><div class="line">                dp[++len] = str.charAt(i);</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">int</span> index = binary(i,dp,str);</div><div class="line">                dp[index] = str.charAt(i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> len;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binary</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">char</span>[] dp,String str)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=dp.length-<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> mid ;</div><div class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</div><div class="line">            mid = (left+right)/<span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>(dp[mid]&gt;str.charAt(i)) right = mid;</div><div class="line">            <span class="keyword">else</span> left = mid+<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> left;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>此方法的时间复杂度降到了nlogn,而前面两个都是n^2</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/06/最长递增子序列（LIS）/" data-id="cj597kukt0026b1x33g4yeqql" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/">algorithm</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-最长公共子序列（LCS）" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/05/最长公共子序列（LCS）/" class="article-date">
  <time class="post-time" datetime="2016-12-05T03:14:08.000Z" itemprop="datePublished">
    <span class="post-month">12月</span><br/>
    <span class="post-day">05</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/05/最长公共子序列（LCS）/">最长公共子序列（LCS）</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/algorithm/">algorithm</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最长公共子序列问题，是典型的动态规划问题。个人认为，符合动态规划的需要满足两个基本的条件</p>
<ul>
<li>目标问题可以划分成众多相同的子问题</li>
<li>子问题具有重叠性<br>划分子问题：当我们拿到一个问题的时候，不可能一眼看出答案，计算机也不行，都要经过复杂的计算。但是如果我们把问题规模变小一点，只看其中的一部分，可能就比较容易得出答案，而我们的出的问题一小部分的答案，对我们计算出此问题的答案是有帮助的。简单说就是子问题的最优解服务于目标问题。例如我们计算BDCABA和ABCBDAB两个串的最长公共子序列。我们一眼肯定看不出答案，但是如果问你B和ABCBDAB的公共子串，那么一眼就看出来了。然后再看BD和ABCBDAB的公共子串，因为我们知道了B和ABCBDAB的子串，所以只关心D和ABCBDAB的子串，然后加上B和ABCBDAB的结果。再往后就是同样的步骤循环往复。<br>重叠性：还是上面的例子，当我们计算B和ABCBDAB的公共子串时，要遍历ABCBDAB串，和B比较，判断是否有和B相同的。然后当我们计算BD和ABCBDAB的公共子串时，我们又要遍历ABCBDAB串，看是否有和B相等的，再判断是否有和D相等的。可以发现，找和B相等的这个步骤明显是重复的，我们在首个子问题已经判断过了。如果两个串非常长，这种重复操作就很耗时，又没有什么意义，dp就是解决这个问题的，他把子问题的最优解保存的表格中，当需要的时候，拿来用就是了，不用重复判断子问题的。<br>下面通过一张图（来自算法导论）分析下dp过程<br><img src="http://ofy9dm2ii.bkt.clouddn.com/image/article/dp.png" alt="LCS"><br>从图中可以看出，它把子问题的结果都存在一张表中了。从左上到右下，问题规模不断扩大，当问题规模扩大的时候，都可以利用扩大之前的结果，在这个基础上继续计算。比如我们走到（x2,y2）这个子问题的时候，之前的子问题结果我们已经拿到了，而且我们知道，在之前的众多子问题中(x2,y1)这个子问题的最优解是符合我们的要求的，所以我们只需要判断当前节点，加上(x2,y1)这个子问题的结果，肯定就是目前的最优解了。这样直到最好，(Xmax,Ymax)就是我们要的最优解<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        String str1 = <span class="string">"BDCABA"</span>;</div><div class="line">        String str2 = <span class="string">"ABCBDAB"</span>;</div><div class="line">        System.out.print(lcs(str1, str2) + <span class="string">""</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lcs</span><span class="params">(String str1, String str2)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[str1.length()+<span class="number">1</span>][str2.length()+<span class="number">1</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= str1.length(); i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= str2.length(); j++) &#123;</div><div class="line">                dp[i][j] = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str1.length(); i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; str2.length(); j++) &#123;</div><div class="line">                <span class="keyword">if</span> (str1.charAt(i) == str2.charAt(j)) &#123;</div><div class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j] + <span class="number">1</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = Math.max(dp[i][j+<span class="number">1</span>], dp[i+<span class="number">1</span>][j]);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dp[str1.length()][str2.length()];</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/05/最长公共子序列（LCS）/" data-id="cj597kukv002bb1x3ee0pzt53" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/">algorithm</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-TCP-UDP" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/02/TCP-UDP/" class="article-date">
  <time class="post-time" datetime="2016-12-02T06:46:38.000Z" itemprop="datePublished">
    <span class="post-month">12月</span><br/>
    <span class="post-day">02</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/02/TCP-UDP/">TCP/UDP</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/net/">net</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><p>TCP/UDP都是属于运输层，那么首先来了解一下运输层。我们知道，IP属于网络层，既然IP就实现了把数据从主机A传送到主机B。那为什么还需要运输层呢？这就不得不说一下IP和运输层的作用范围了。IP只负责把数据从A主机传送到B主机，这显然没有完成通信工作。我们平时上网时，发送和接收数据的完整流程是从我们上网用的联网程序（例如浏览器）到我们的PC再到目标主机，再到目标主机的服务器程序。然后同样的路径，目标主机的服务器会把我们请求的数据返回到我们的联网程序。从这个过程可以看出，IP能做的只是整个过程的中间一端，它并不能把数据直接送到PC上的应用程序，后面的工作，就是运输层要做的事情。我们说端到端通信，其实就是应用程序之间的通讯，也就是进程间通讯。运输层有个很重要的功能就是复用和分用，复用是指不同应用程序可以用同一个运输协议传送数据，分用是指，当一个应用程序跟多个远程应用通信的时候，运输层剥去报文首部后，能正确的把消息传给相应的程序</p>
<h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>前面提到，IP只负责把数据送到目的主机，运输层负责送到对应的应用程序，那么运输层怎么知道该送给哪个应用程序呢？这就是端口诞生的原因。有了端口号，我们甚至不用关心实现这个功能的是哪个进程，只需按端口号发送数据就行了。端口是一个16位的整数，共有65535个。其中有0~1023被系统端口占用，1024~49151是登记端口，使用这些端口必须登记，剩下的就是客户端使用的端口，又叫短暂端口，当一次链接断开后，端口就可以给其他客户端使用。</p>
<h2 id="TCP-UDP概述"><a href="#TCP-UDP概述" class="headerlink" title="TCP/UDP概述"></a>TCP/UDP概述</h2><p>TCP翻译为传输控制协议 面向连接。UDP翻译为用户数据报协议 面向无连接<br><img src="http://ofy9dm2ii.bkt.clouddn.com/image/article/tcpudp1.png" alt="TCP/UDP体系"></p>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>面向无连接（发送前不需要建立连接，减少开销和发送数据之前的延时）</li>
<li>尽最大努力交付（但不保证交付）</li>
<li>面向报文（应用程序发过来的报文，UDP加上自己的头部，直接传给IP层，不做其他的修饰和分割。接收方接收后去掉UDP头部，就返给应用程序，由应用程序解析）</li>
<li>没有拥塞控制（允许有小部分数据丢失，但是不允许有较大的时延）</li>
<li>支持一对多，一对一，多对多的交互通信</li>
<li>首部开销少<br>通过上面的特点可以看出，UDP结构和实现还是比较简单的，最重要的就是他的首部格式了</li>
<li>源端口</li>
<li>目的端口</li>
<li>长度（UDP数据报的长度）</li>
<li>检验和<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3></li>
<li>面向连接（传输数据前必须建立TCP连接，传输完成后必须关闭连接）</li>
<li>只允许点对点通信</li>
<li>提供可交付服务</li>
<li>全双工通信（发送端和接收端都设置了发送缓存和接收缓存，应用程序只需要把数据发送给发送缓存就行了，TCP会在合适的时候发送，同样，应用程序拿数据的时候，也只需要在接收缓存里拿）</li>
<li>面向字节流（TCP不关心发送方把数据分了几块，也不关心字节发送的顺序，它的任务是保证发送的总的字节流和接收的总的字节流相同，发送端可以根据数据长度，自由切割，接收方可以用任意个块接收）<h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3>TCP是点到点连接，它的端点指的不是主机，不是IP地址也不是应用程序，而是套接字：ip：port<h3 id="可靠的传输协议"><a href="#可靠的传输协议" class="headerlink" title="可靠的传输协议"></a>可靠的传输协议</h3><h4 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h4>通过名字就可以知道原理。当发送一组数据后就停止发送，等待接收端的相应，得到确认信息后再发送下一个分组。当出现错误时，就重新发送。发送分组时，都会设置一个定时器，设定超时时间，当超过超时时间没有得到回应后，就判断出错，重新发送。这里要注意几点</li>
<li>发送一个分组后，要保留分组的备份，以便失败重传</li>
<li>必须对发送分组和确认分组编号，以便知道发送或确认接收的是哪个分组</li>
<li>超时定时器时间应该比平均传输时间长一些，因为发送数据时并不知道走那些路由，也不知道网络状况，很有可能有延时<br>此协议对确认丢失的做法是重传，对确认迟到的做法是忽略。<br>很明显，此协议的最大缺点就是信道利用率很低<br><img src="http://ofy9dm2ii.bkt.clouddn.com/image/article/tcpudp2.png" alt="此处输入图片的描述"><h4 id="连续ARQ协议（滑动窗口协议）"><a href="#连续ARQ协议（滑动窗口协议）" class="headerlink" title="连续ARQ协议（滑动窗口协议）"></a>连续ARQ协议（滑动窗口协议）</h4><img src="http://ofy9dm2ii.bkt.clouddn.com/image/article/tcpudp3.png" alt="此处输入图片的描述"><br>图a表示发送窗口，在发送窗口内的分组都可以连续发送出去，不需要等待前一个确认，这样就提高了信道利用率。发送方每收到一个确认，就把窗口向前滑动一个距离。接收方采用累积确认的方式，对按序到达的最后一个分组确认。当发送方接到确认后，就认为在这个序号之前的分组都已经确认到达了。这种方式优缺点很明显，优点是容易实现，缺点是中间有失败的分组发现不了<h3 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h3>所谓流量控制，就是让发送方的发送速率不要太快，让接收方能来得及接收。采用滑动窗口的机制实现流量控制：TCP初次建立连接的时候，接收方会返回给发送方一个窗口大小，发送方发送数据时，不得超过这个数值。<br><img src="http://ofy9dm2ii.bkt.clouddn.com/image/article/liuliangkongzhi.png" alt="流量控制"><br>从图中我们可以清晰看出，是由接收方控制窗口大小，进而控制流量。只有当ACK=1时，确认字段才有意义。这里我们可以发现个问题。首先图中如果接收方返回的窗口大小为0，那么发送方就不能再发数据了。假设现在返回的窗口大小就是0，但是过一段时间后接收方的缓存中又有了些地方了（可能是应用程序读了缓存数据），这时接收方再给发送方发个rwnd = 400的消息，但是消息再网络中丢失了。这个时候就好玩了，接收方想着，我已经给你说了，我这有400大小空间，我等你你发数据来。发送方却认为，我收到了窗口为0的消息，所以我什么都不能发。这样僵持下去，不就是死循环吗。解决这个问题，采用的是持续计时器。当收到0窗口通知时，就开启持续计时器，若计时器到时间了，就发送个探测报文（1字节）给对方，对方看到后会给出当前的窗口值<h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就会变坏，这就是拥塞。<br>拥塞解决的关注点在于各个部分的平衡，不能只着眼于某一部分。举个例子，从刚才对拥塞的描述可知。就是资源不够了呗，那我加点资源不就好了（扩大路由缓存）。但是这个时候，路由缓存被扩大了，导致可以接受更多的资源，也就是在这个路由上的资源队列变长了，由于链路的容量和处理机的速度跟不上，结果就会导致部分资源超时，超时怎么办？重传，重传后队列还是长，再超时，这样岂不是变的更糟？那可能又说了，不是怪链路容量和处理机速度吗，换。可是你换了，还是会导致其他问题，只是把问题转移了。<h4 id="几种拥塞控制的方法"><a href="#几种拥塞控制的方法" class="headerlink" title="几种拥塞控制的方法"></a>几种拥塞控制的方法</h4></li>
<li>慢开始（就是说开始发送数据时，让发送窗口等于1，收到回复后，再让发送窗口等于2.就是每次发送窗口数是原来的2倍，这样缓慢的增加数据量，比一开始就一股脑的发送出去，更可以避免拥塞）</li>
<li>拥塞避免（拥塞避免是在每次发送数据的时候，让窗口加一，而不是相对于上次成倍增加，这个想想也是需要的，如果一直成指数增长，迟早会造成拥塞）</li>
<li>快重传（当接收方对某次的数据连续返回3次重复确认后，说明这次数据的后面一组数据丢失，此时发送方可以理解重传，而没必要等超时）</li>
<li>快恢复（快恢复和快重传查不到，只是实现策略不同，快恢复把慢开始门限减半后，不执行慢开始，而是把窗口大小减小为门限一般，然后采用拥塞避免方式是窗口增大）<br>慢开始门限：当刚开始发送数据时，采用的是慢开始，也就是发送窗口指数增长，但是肯定不能一直指数啊，否则肯定会拥塞的，这里就慢开始门限的作用，当窗口大小到达门限时，就采用拥塞避免策略，让窗口缓慢增长。<br><img src="http://7xslom.com1.z0.glb.clouddn.com/yongsekongzhi.png" alt="拥塞控制"><br>图中我们还可以看出，当发送拥塞的时候，门限会将为原来的一半，rwnd会重新从1开始。上面说快速恢复的特点，就是说当门限降为一半后，没有采用慢开始rwnd=1的策略，而是rwnd=门限/2后采用拥塞避免。主要是因为，此时网络不一定是拥塞，只是某部分数据丢了。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/02/TCP-UDP/" data-id="cj597kujb000kb1x3xtdba5mr" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/net/">net</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-ICMP" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/02/ICMP/" class="article-date">
  <time class="post-time" datetime="2016-12-02T05:54:19.000Z" itemprop="datePublished">
    <span class="post-month">12月</span><br/>
    <span class="post-day">02</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/02/ICMP/">ICMP</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/net/">net</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="ICMP概念"><a href="#ICMP概念" class="headerlink" title="ICMP概念"></a>ICMP概念</h2><p>ICMP全称：Internet Control Message Protocol 翻译过来就是网际控制报文协议。目的是有效的转发IP数据报和提高交付成功的机会。ICMP不是高层协议，是IP层的协议。ICMP报文作为IP数据报的数据，加上数据报的首部组成IP数据报发送出去<br><img src="http://ofy9dm2ii.bkt.clouddn.com/icmp1.png" alt="ICMP报文格式"></p>
<h2 id="ICMP种类"><a href="#ICMP种类" class="headerlink" title="ICMP种类"></a>ICMP种类</h2><p>ICMP报文有两种：ICMP差错报告报文和ICMP询问报文<br><img src="http://ofy9dm2ii.bkt.clouddn.com/image/article/icmp2.png" alt="ICMP报文类型"></p>
<ul>
<li>终点不可达：当路由器或主机不能交付数据时就向源点发送此报告</li>
<li>源点抑制：当路由或主机由于拥塞而丢失数据的时候，向源点发送此报告，使源点知道应该把数据报的速率放慢</li>
<li>时间超过：当路由器收到时间为0的数据报时除丢弃数据报外，还要向源点发送此报文。当终点在预定的时间内没有收到全部数据时，会丢弃已收到的所有数据并向源点发送此报文</li>
<li>参数问题：当路由或目的主机收到的数据有问题时发送</li>
<li>改变路由：路由把改变路由报文发给源主机，让主机知道下次应该用哪个路由<br>每个主机都有个默认路由，初始时，主机总是把数据发给默认路由，由默认路由寻找合适的路由或主机转发，当默认路由找到合适的路由，并认为以后主机应该直接发给那个路由，不用通过默认路由的时候，就会给源主机发送改变路由的报文，源主机在自己的路由表中增加一个项目，以后就会直接发给相应的路由<h2 id="ICMP应用"><a href="#ICMP应用" class="headerlink" title="ICMP应用"></a>ICMP应用</h2>在window系统中，我们常用的ping命令，就是ICMP。当执行ping命令的时候，PC机会一连发出多条回送请求报文<br>还有个非常有用的功能是 tracert，就是跟踪源主机到目的主机的路径。<br>实现方式：<br>tracerout向目的主机发送一连串的IP数据，都是不可交付的UDP数据。第一个的TTL设置为1，当第一个路由接收到后TTl-1，变成0，则丢弃数据；第二次TTL设置成2，当第二个路由收到后，TTL变为0，丢弃数据。这样一直到目的主机（目的主机无法对TTL操作，但是由于发送的是不可交付的UDP数据，因此会向源主机发送中点不可达的ICMP）。由于每次TTL变为0，数据时间超过，会给源主机发送时间超过的ICMP报文，则源主机就记住了从源主机到目的主机的路径</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/02/ICMP/" data-id="cj597kuj30008b1x3xbh7is49" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/net/">net</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-快慢指针-归并" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/02/快慢指针-归并/" class="article-date">
  <time class="post-time" datetime="2016-12-02T01:49:45.000Z" itemprop="datePublished">
    <span class="post-month">12月</span><br/>
    <span class="post-day">02</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/02/快慢指针-归并/">快慢指针+归并</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/algorithm/">algorithm</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><h3 id="快慢指针概述"><a href="#快慢指针概述" class="headerlink" title="快慢指针概述"></a>快慢指针概述</h3><p>从名字上看，就很直观，就是一个快指针，一个慢指针，快慢的判定，是根据指针每次移动的跨度决定的。比如，慢指针每次跨度为1，即：lowPoint = root.next.快指针每次移动的跨度为2，即：fastPoint = root.next.next。</p>
<h3 id="快慢指针能解决的问题"><a href="#快慢指针能解决的问题" class="headerlink" title="快慢指针能解决的问题"></a>快慢指针能解决的问题</h3><ul>
<li>找链表的中点</li>
<li>判断链表有没有环，有环的话找到环的入口<h3 id="快慢指针针对问题的实现"><a href="#快慢指针针对问题的实现" class="headerlink" title="快慢指针针对问题的实现"></a>快慢指针针对问题的实现</h3><h5 id="链表中点"><a href="#链表中点" class="headerlink" title="链表中点"></a>链表中点</h5>当我们想找一个链表的中点时，一般做法是先遍历一遍链表，获取链表的长度，然后再从头遍历，找到中点返回。显然性能是比较低的。根据上面概述所说。我们可以想到，我们可以用快慢指针的思想快速的找到中点。开始快慢指针指向链表的头部，慢指针每次跨度为1，快指针每次跨度为2.那么当快指针到达链表尾部的时候（这里假设链表无环），慢指针刚好指向链表的中点。用这种方法，较第一种来说，就快很多了，代码也是很简单<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public static Node getMid(Node root)&#123;</div><div class="line">    if(root == null)return null;</div><div class="line">    Node low = root;</div><div class="line">    Node fast = root.next;</div><div class="line">    while(fast.next!=null &amp;&amp; fast.next.next!=null)&#123;</div><div class="line">        low = low.next;</div><div class="line">        fast = fast.next.next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return low;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="判断链表是否有换，有环找出环的入口"><a href="#判断链表是否有换，有环找出环的入口" class="headerlink" title="判断链表是否有换，有环找出环的入口"></a>判断链表是否有换，有环找出环的入口</h5><p>当我们用快慢指针遍历一个链表的时候，如果慢指针能和快指针相遇，那么可以确定链表有环，从我们找链表中点也可以看出，如果没有环，快指针肯定早早的就走了链表尽头了。那么判断链表是否有环已经解决了，是不是感觉超简单的。当我们知道链表有环的时候，怎么利用快慢指针找到环的入口呢？这里先给出方法，再解释为什么。当我们判断链表存在环时，也就是快慢指针相遇了。此时，我们让快指针指向表头，并把速度降下来，每次跨度为1.当慢下来的快指针再次和慢指针相遇的时候，就是链表的入口。下面就结合一张图解释下为什么这样是可行的<br><img src="http://ofy9dm2ii.bkt.clouddn.com/image/article/point.png" alt="存在环的链表"><br>首先图是巨丑的，如果感觉辣眼睛，自己画一个吧。如图，可以手动模拟一下快慢指针的运动，你会发现，他们在6这个节点相遇。此时我们已经能判断此链表存在环了。那么我们还能得到什么信息呢？我们假设慢指针走了N步（虽然我知道是6步，要学会抽象，我们要解决的是所有类似问题，不是这一个特例），那么显然快指针走了2*N步。得到这个信息我们可以知道，如果再让慢指针走N步，它还会走到6这里，这个应该不难理解，因为它再走N步就追上现在这个状态的快指针了，而快指针刚好停在6上。整理下信息，慢指针从头走到6用N步，再走N步又会再走到N步，那么此时如果我们在表头设置另一个慢指针，那么它走N步后也会停到6.也就是2个慢指针肯定会在6这个节点相遇。确定了这个，我们在从后往前推，他们速度一样，在6相遇了，那么在5肯定是相遇的，在4也是相遇的，同样在3也是相遇的。也就是说他们在环内走的路程是一样的，那么肯定在环扣就相遇了，不然一样的速度，怎么能在环内开心的一起走呢？思路分析完了，代码就简单了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">func</span><span class="params">(Node root)</span></span></div><div class="line">&#123;</div><div class="line">   Node fast, slow;</div><div class="line">    fast = slow = Head;</div><div class="line">    <span class="keyword">while</span>(fast != slow &amp;&amp; fast != <span class="keyword">null</span>)</div><div class="line">    &#123;</div><div class="line">        slow = slow.next;</div><div class="line">        fast = fast.next;</div><div class="line">        <span class="keyword">if</span>(fast != <span class="keyword">null</span>)</div><div class="line">            fast = fast.next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(fast == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    fast = Head;</div><div class="line">    <span class="keyword">while</span>(fast != slow)</div><div class="line">    &#123;</div><div class="line">        fast = fast.next;</div><div class="line">        slow = slow.next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> fast;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>##归并</p>
<h3 id="归并概念"><a href="#归并概念" class="headerlink" title="归并概念"></a>归并概念</h3><p>先递归，再合并，就这么简单，算法的思想在名字上表露无疑。</p>
<h3 id="归并算法实现原理和过程"><a href="#归并算法实现原理和过程" class="headerlink" title="归并算法实现原理和过程"></a>归并算法实现原理和过程</h3><p>下面就通过一张图，分析归并的流程<br><img src="http://ofy9dm2ii.bkt.clouddn.com/image/article/guibing.jpeg" alt="归并流程图"><br>通过递归方式，不断拆分数组，直到每个子数组只有一个数字，此时认为每个子数组有序，比如图中的第三行。当每个子数组有序后，再让相邻的子数组合并，合并的时候开一个新的数组，把值小的一次往里放，时间复杂度是线性的。这样合并到最后，就是一个有序的数组<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> first, <span class="keyword">int</span> last, <span class="keyword">int</span> temp[])</span>  </span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">if</span> (first &lt; last)  </div><div class="line">    &#123;  </div><div class="line">        <span class="keyword">int</span> mid = (first + last) / <span class="number">2</span>;  </div><div class="line">        mergesort(a, first, mid, temp);    <span class="comment">//左边有序  </span></div><div class="line">        mergesort(a, mid + <span class="number">1</span>, last, temp); <span class="comment">//右边有序  </span></div><div class="line">        mergearray(a, first, mid, last, temp); <span class="comment">//再将二个有序数列合并  </span></div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergearray</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> first, <span class="keyword">int</span> mid, <span class="keyword">int</span> last, <span class="keyword">int</span> temp[])</span>  </span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">int</span> i = first, j = mid + <span class="number">1</span>;  </div><div class="line">    <span class="keyword">int</span> m = mid,   n = last;  </div><div class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;  </div><div class="line">      </div><div class="line">    <span class="keyword">while</span> (i &lt;= m &amp;&amp; j &lt;= n)  </div><div class="line">    &#123;  </div><div class="line">        <span class="keyword">if</span> (a[i] &lt;= a[j])  </div><div class="line">            temp[k++] = a[i++];  </div><div class="line">        <span class="keyword">else</span>  </div><div class="line">            temp[k++] = a[j++];  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="keyword">while</span> (i &lt;= m)  </div><div class="line">        temp[k++] = a[i++];  </div><div class="line">      </div><div class="line">    <span class="keyword">while</span> (j &lt;= n)  </div><div class="line">        temp[k++] = a[j++];  </div><div class="line">      </div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; i++)  </div><div class="line">        a[first + i] = temp[i];  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这是归并的递归方式，非递归这次暂且不讲。</p>
<p>##实战<br>给一个链表排序呢，要求时间复杂度为nlogn。题目很简单（我说的是文字很少），用到的知识点就是上面说的快慢指针+归并排序，两个算法已经分析过了，二者一结合就是本题答案，不再过多解释了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//快慢指针找中点</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getMid</span><span class="params">(Node root)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        Node low = root;</div><div class="line">        Node fast = root.next;</div><div class="line">        <span class="keyword">while</span>(fast.next!=<span class="keyword">null</span> &amp;&amp; fast.next.next!=<span class="keyword">null</span>)&#123;</div><div class="line">            low = low.next;</div><div class="line">            fast = fast.next.next;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> low;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//先递归拆分数组，再把有序子数组合并，可以结合上面的图理解</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">sort</span><span class="params">(Node root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span>(root.next == <span class="keyword">null</span>) <span class="keyword">return</span> root;</div><div class="line">    Node mid = getMid(root);</div><div class="line">    Node tail = mid.next;</div><div class="line">    mid.next = <span class="keyword">null</span>;</div><div class="line">    Node head1 = sort(root);</div><div class="line">    Node head2 = sort(tail);</div><div class="line">    root = merg(head1,head2);</div><div class="line">    <span class="keyword">return</span> root;</div><div class="line">&#125;</div><div class="line"><span class="comment">//两个子数组合并过程（当然这里是子链表）</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">merg</span><span class="params">(Node a,Node b)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(a == <span class="keyword">null</span>) <span class="keyword">return</span> b;</div><div class="line">        <span class="keyword">if</span>(b == <span class="keyword">null</span>) <span class="keyword">return</span> a;</div><div class="line">        Node head;</div><div class="line">        Node tail;</div><div class="line">        <span class="keyword">if</span>(a.val &gt; b.val)&#123;</div><div class="line">            head = b;</div><div class="line">            tail = b;</div><div class="line">            b = b.next;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            head = a;</div><div class="line">            tail = a;</div><div class="line">            a = a.next;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(a!=<span class="keyword">null</span> &amp;&amp; b!=<span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(a.val &gt; b.val)&#123;</div><div class="line">                tail.next = b;</div><div class="line">                b = b.next;</div><div class="line">                tail = tail.next;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                tail.next = a;</div><div class="line">                tail = tail.next;</div><div class="line">                a = a.next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(a!=<span class="keyword">null</span>)&#123;</div><div class="line">            tail.next = a;</div><div class="line">            tail = tail.next;</div><div class="line">            a = a.next;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(b!=<span class="keyword">null</span>)&#123;</div><div class="line">            tail.next = b;</div><div class="line">            b = b.next;</div><div class="line">            tail = tail.next;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> head;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/02/快慢指针-归并/" data-id="cj597kukm001vb1x37ypjlds2" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/">algorithm</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-IP详解" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/29/IP详解/" class="article-date">
  <time class="post-time" datetime="2016-11-29T06:37:50.000Z" itemprop="datePublished">
    <span class="post-month">11月</span><br/>
    <span class="post-day">29</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/29/IP详解/">IP详解</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/net/">net</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="分类的IP地址"><a href="#分类的IP地址" class="headerlink" title="分类的IP地址"></a>分类的IP地址</h2><p>IP地址分为A类、B类、C类、D类、E类。</p>
<ul>
<li>A类、B类和C类地址的网络号字段分别为1，2，3字节长度，而在网络号字段的最前面有1~3位的类别位，其数值分别规定为0，10，110.</li>
<li>A类、B类和C类地址的主机号字段分别为3个、2个、1个字节长。</li>
<li>A类、B类、C类地址为单播（一对一通信），D类地址为多播（一对多通信），E类地址为保留地址<br><img src="http://ofy9dm2ii.bkt.clouddn.com/image/article/9922770D-79D6-4414-A0B9-242852A2C174.png" alt="IP地址中的网络号字段和主机字段"><br>从IP地址的结构看，IP地址并不仅仅指明一个主机，还指明一个主机连接到的网络。把IP分为A类、B类、C类是为了满足不同用户的需求。当某个单位申请到一个IP地址时，实际上是指获得了具有同样网络号的一块地址。对于主机和路由器来说，IP都是32位的二进制，为了方便记忆，我们采用点分十进制表示一个IP<br><img src="http://ofy9dm2ii.bkt.clouddn.com/IP2.png" alt="IP的点分十进制表示法"><h2 id="常用的三类IP地址"><a href="#常用的三类IP地址" class="headerlink" title="常用的三类IP地址"></a>常用的三类IP地址</h2><h3 id="A类"><a href="#A类" class="headerlink" title="A类"></a>A类</h3>A类的网络号字段占一个字节，只有7位可供使用（该字段的第一位已经固化为0），但可指派的网络号为126个（即2^7-2）。减2的原因是：第一，IP地址的全0表示“这个（this）”。网络号全0表示保留地址，意思是“本网络”。第二，网络号为127（01111111）保留作为本地软件环回测试本主机的进程间通信之用。若主机发送一个目的地址为环回地址（127.0.0.1）的IP数据报，则本主机的协议软件就会处理数据报总的数据，而不会把数据报发送到任何网络。A类地址的主机�号占3个字节，因此每个A类主机的最大  主机数是2^24-2，即16777214，这里减2的原因：全0主机字段表示本主机所连接到的单个网络地址（例如 一主机IP为5.6.7.8，则该主机所在的网络地址为5.0.0.0）而1表示所有的（all）。IP地址空间总共有2^32(即4294967296)个地址，整个A类地址有2^31个地址，A类占了50%<h3 id="B类"><a href="#B类" class="headerlink" title="B类"></a>B类</h3>B类地址的网络号占2个字节，但前两位已经固化（10），还剩下14位进行分配。因为网络号后面的14位无论如何都不会出现使网络号字段出现全0全1的情况，所以不存在减2，但是128.0.0.0是不指派的，B类最小指派128.1.0.0，所以可以指派的网络数为2^14-1，即16383。B类地址每一个网络上最大的主机数为2^16-2，减2原因同上，整个B类地址空间有2^30个地址，占整个IP地址空间的25%。<h3 id="C类"><a href="#C类" class="headerlink" title="C类"></a>C类</h3>网络号3字节，前3位固化（110）,21位可分，192.0.0.0不分配，分配最小为192.0.1.0，可指派总网络数2^21-1(2097151),最大主机数2^8-2(254),整个地址空间有2^19个，占12.5%<br><img src="http://ofy9dm2ii.bkt.clouddn.com/image/article/IP3.png" alt="IP地址的指派范围"><h2 id="IP地址特点"><a href="#IP地址特点" class="headerlink" title="IP地址特点"></a>IP地址特点</h2>IP地址分为网络号（第一级）和主机号（第二级）两部分。这样IP地址管理机构只需要关心网络号，主机号段由用户管理。路由在分组转发的时候，也是只关心网络号，不关心主机号，这样能节约大量的路由存储空间。一个路由器至少链接2个网络，所以一个路由器至少有两个IP。一个网络是指具有相同网络号的众多主机的集合，因此，用转发器和桥接器链接的若干局域网为同一个网络。具有不同网络号的局域网必须由路由器链接<h2 id="Ip地址和硬件地址"><a href="#Ip地址和硬件地址" class="headerlink" title="Ip地址和硬件地址"></a>Ip地址和硬件地址</h2>物理地址是数据链路层和物理层使用的地址，IP地址是网络层及以上层使用的地址，是一种逻辑地址。<br><img src="http://ofy9dm2ii.bkt.clouddn.com/IP4.png" alt="IP地址和硬件地址"><br>IP地址放在IP数据报的首部，硬件地址放在MAC帧的首部，当IP数据放入数据链路层的MAC帧中时，整个IP数据报就是MAC帧的一部分，因而数据链路层看不到IP地址的存在。IP抽象了互联网屏蔽了底层复杂而又各不相同的细节，所以才使世界上众多型号，规格各不相同的主机能相互通信。互联网只关心IP，具体的MAC地址，交给主机自行处理<h2 id="地址解析协议ARP和逆地址解析协议RARP"><a href="#地址解析协议ARP和逆地址解析协议RARP" class="headerlink" title="地址解析协议ARP和逆地址解析协议RARP"></a>地址解析协议ARP和逆地址解析协议RARP</h2>简单概括，ARP就是把IP地址解析成MAC地址，RARP就是把MAC地址解析成IP地址。<br>每个主机的ARP告诉缓存中存放了一张IP地址和MAC地址映射的表，并且会经常更新（因为某些主机的IP会发生变动，经常更新可以及时删除掉无用的IP，也可以及时增加新加入的IP）。当主机A向主机B发送数据时，主机A先在自己的高速缓存表中查看主机B的IP对应的MAC，如果没有发现B的IP，那么就在本局域网中发送一个广播，当B接收到广播后会回复给A。A，B会把对方的IP写入自己的告诉缓存表中，下次再通讯就可以直接发送。<h2 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h2><h3 id="两级IP的缺点"><a href="#两级IP的缺点" class="headerlink" title="两级IP的缺点"></a>两级IP的缺点</h3></li>
<li>IP地址空间利用率低。每个A类地址网络可连接的主机超过1000万，但一般达不到这个数量级</li>
<li>路由表太大导致网络性能降低。每一个路由器都应当能够从路由表查出怎么到下一跳路由器，因此互联网中的网络数越多路由器的路由表就越大，查询性能就越差</li>
<li>两级IP不够灵活<h3 id="子网的划分"><a href="#子网的划分" class="headerlink" title="子网的划分"></a>子网的划分</h3>划分子网的方法是从网络的主机号上借若干位作为子网号，对于外界来说，网络没有变化。那么当路由接收到发给子网的信息后，它怎么去找这个子网，因为对于路由来说，网络是没有变化的。此时就需要子网掩码的存在了。子网掩码和IP地址诸位相与就得出子网地址。现代路由器的路由表中必须存放子网掩码和对应的IP<br><img src="http://ofy9dm2ii.bkt.clouddn.com/IP5.png" alt="各类网络默认的子网掩码"><br><img src="http://ofy9dm2ii.bkt.clouddn.com/IP6.png" alt="B类网络的子网划分"><br>可以看出，划分的子网越多，每个子网所能链接的主机数就越少。同时可以看出，子网数*每个子网能链接的主机数，一定是小于B类网络能链接的总主机数的。不同的子网掩码可能得出相同的子网，但是子网掩码不同，表示所能链接的主机数不同。例如IP：141.14.72.24，子网掩码分别是255.255.192.0和255.255.224.0<h3 id="划分子网的情况下，路由转发"><a href="#划分子网的情况下，路由转发" class="headerlink" title="划分子网的情况下，路由转发"></a>划分子网的情况下，路由转发</h3>当A主机向B主机发送数据时。A主机首先用目的地址和子网掩码得出IP，在局域网中找，找不到，交给默认路由。路由接到后，在用路由表中的每行数据（下级路由IP和子网掩码）的子网掩码和目标地址得出IP，与本行数据的IP比较，看是否需要跳转。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/29/IP详解/" data-id="cj597kuj20007b1x3rsylsthy" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/net/">net</a></li></ul>

    </footer>
  </div>
  
</article>




  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; pre</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">next &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <h1 class="blog-title">逝去的美好</h1>
    <h2 class="blog-subtitle">无论做什么，兴趣还是最重要的</h2>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://avatars0.githubusercontent.com/u/20333903?v=3&amp;s=460">
    <h2 class="author">geekzw</h2>
    <h3 class="description">null</h3>
    <div class="count-box">
      <a href="/archives"><div><strong>30</strong><br>文章</div></a>
      <a href="/categories"><div><strong>7</strong><br>分类</div></a>
      <a href="/tags"><div><strong>6</strong><br>标签</div></a>
    </div>



    <div class="social-link">
      
        <a class="hvr-bounce-in" href="http://github.com/ShanaMaid" target="_blank" title="Github">
          Github
        </a>
      
    </div>

    <div class="friend-link">
      <h2>友情链接</h2>
      
        <a class="hvr-bounce-in" href="http://blog.shanamaid.top/" target="_blank" title="ShanaMaid">
          ShanaMaid
        </a>
      
    </div>
  </div>
</div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy;2016 - 2017 geekzw<br>
      由<a href="http://hexo.io/" target="_blank">Hexo</a>强力驱动 | 
      主题-<a href="https://github.com/ShanaMaid/hexo-theme-shana">Shana</a>
      
    </div>
    
  </div>
</footer>
    </div>
    

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="//apps.bdimg.com/libs/wow/0.1.6/wow.min.js"></script>
<script>
new WOW().init();
</script>   


  <link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">
  <script src="/plugin/fancybox/jquery.fancybox.pack.js"></script>



  <link rel="stylesheet" href="/plugin/galmenu/GalMenu.css">
  <script src="/plugin/galmenu/GalMenu.js"></script>
  <div class="GalMenu GalDropDown">
      <div class="circle" id="gal">
        <div class="ring">
          
            <a href="/" title="" class="menuItem">首页</a>
          
            <a href="/tags" title="" class="menuItem">标签</a>
          
            <a href="/categories" title="" class="menuItem">分类</a>
          
            <a href="/archives" title="" class="menuItem">归档</a>
          
            <a href="/xxxxxxxxx" title="" class="menuItem">xxx</a>
          
            <a href="/xxxxxxx" title="" class="menuItem">xxxx</a>
          
        </div>
        
          <audio id="audio" src="#"></audio>
        
      </div> 
</div>
<div id="overlay" style="opacity: 1; cursor: pointer;"></div>
  <script type="text/javascript">var items = document.querySelectorAll('.menuItem');
    for (var i = 0,
    l = items.length; i < l; i++) {
      items[i].style.left = (50 - 35 * Math.cos( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%";
      items[i].style.top = (50 + 35 * Math.sin( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%"
    }</script>
<script type="text/javascript">
  $(document).ready(function() {
    $('body').GalMenu({
      'menu': 'GalDropDown'
    })
  });
</script>

  <section class="hidden-xs"> 
  <ul class="cb-slideshow"> 
    <li><span>苟利</span></li> 
    <li><span>国家</span></li> 
    <li><span>生死以</span></li> 
    <li><span>岂能</span></li> 
    <li><span>祸福</span></li> 
    <li><span>趋避之</span></li> 
  </ul>
</section>
<script src="/js/script.js"></script>



  </div>
</body>
</html>